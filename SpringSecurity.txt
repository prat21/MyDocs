Watch Java Brains.
Just watch JWT and OAuth part. Do not follow the coding videos. Just know the concept. Coding videos are outdated.
Note: The WebSecurityConfigurerAdapter is deprecated. Instead, beans needs to registered(for example SecurityFilterChain).
Please check https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter
-------------------------------------------------------
OAuth is an auth framework that defines how a client application can get limited access to a user's resource(s) without sharing the user's credentials with client.
OAuth is an authorization(and not authentication) mechanism, ie after the user has been authenticated using a proper authentication mechanism(example authentication using username/password where the repository of username/password maybe in-memory, database, ldap etc) a jwt token(similar to session token) is handed to the user as an authorization token which can be used in further calls to access protected resource in resource server.
OAuth is an authorization flow whereas as JWT is about token format(alternate being Opaque token).
-------------------------------------------------------
https://datatracker.ietf.org/doc/html/rfc6749#section-1.1

Access tokens are issued to third-party clients by an authorization server with the approval of the resource owner.  The client uses the access token to access the protected resources hosted by the resource server.
For example, an end-user (resource owner) can grant a printing service (client) access to her protected photos stored at a photo-sharing service (resource server), without sharing her username and password with the printing service. This specification is designed for use with HTTP. The use of OAuth over any protocol other than HTTP is out of scope.

resource owner:
      An entity capable of granting access to a protected resource.
resource server:
      The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens.
client:
      An application making protected resource requests on behalf of the resource owner and with its authorization. The term "client" does not imply any particular implementation characteristics (e.g., whether the application executes on a server, a desktop, or other devices).

authorization server:
      The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization.

The authorization server may be the same server as the resource server or a separate entity. A single authorization server may issue access tokens accepted by multiple resource servers.
----------------------------------------------------------
In authorization code flow,
1) The client requests authorization from the resource owner. The authorization request can be made directly to the resource owner, or preferably indirectly via the authorization server as an intermediary.
2) The resource owner authenticates to the authorization server. The client receives an authorization grant, which is a credential representing the resource owner's authorization.
3) The client uses this auth code(authorization grant) and sends it back, alongwith its client credentials(ie client id and secret), to the authorization server. In this way client authenticates itself.
4) The authorization server authenticates the client and validates the authorization grant, and if valid, issues an access token, which the client uses for accessing a protected resource in resource server.
5) The Resource server validates the access token with the authorization server. If valid, it responds with the requested resource.
----------------------------------------------------------
https://datatracker.ietf.org/doc/html/rfc6749#section-1.3

Authorization Grant:
An authorization grant is a credential representing the resource owner's authorization (to access its protected resources) used by the client to obtain an access token. This specification defines four grant types -- authorization code, implicit, resource owner password credentials, and client credentials.
Because the resource owner only authenticates with the authorization server, the resource owner's credentials are never shared with the client.
The authorization code provides a few important security benefits, such as the ability to authenticate the client, as well as the transmission of the access token directly to the client without passing it through the resource owner's user-agent and potentially exposing it to others, including the resource owner.

In Authorization code flow:
The authorization code is obtained by using an authorization server as an intermediary between the client and resource owner. Instead of requesting authorization directly from the resource owner, the client directs the resource owner to an authorization server, which in turn directs the resource owner back to the client with the authorization code.

In Implicit Flow:
In the implicit flow, instead of issuing the client an authorization code, the client is issued an access token directly (as the result of the resource owner authorization). The grant type is implicit, as no intermediate credentials (such as an authorization code) are issued (and later used to obtain an access token).
When issuing an access token during the implicit grant flow, the authorization server does not authenticate the client.
Implicit grants improve the responsiveness and efficiency of some clients (such as a client implemented as an in-browser application, like outlook web app), since it reduces the number of round trips required to obtain an access token.

Resource Owner Password Credentials:
The resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token.

In Client credentials flow,
The client directly requests access token from the authorization server with its client credentials. Since the client is the owner of the resource being requested.
-------------------------------------------------------
https://datatracker.ietf.org/doc/html/rfc6749#section-2
Before initiating the protocol, the client registers with the authorization server.
-------------------------------------------------------
https://datatracker.ietf.org/doc/html/rfc6749#section-3
The authorization process utilizes two authorization server endpoints (HTTP resources):
   o  Authorization endpoint - used by the client to obtain authorization from the resource owner via user-agent redirection.
   o  Token endpoint - used by the client to exchange an authorization grant for an access token, typically with client authentication.
-------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/oauth2/index.html#oauth2-overview
-------------------------------------------------------
OAUTH2 RESOURCE SERVER (This is basically the setup of the resource server, where resource server needs the authorization server path using which it can validate the oauth tokens.
):
https://docs.spring.io/spring-security/reference/servlet/oauth2/index.html#oauth2-resource-server-access-token
Just check this link for oauth(jwt based) resource server(the section named "Protect Access with an OAuth2 Access Token" -> "JWT support"). No need to see "Opaque Token support" or "Protect Access with a custom JWT".
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://my-auth-server.com
-------------------------------------------------------
OAUTH2 CLIENT WITH CLIENT_CREDENTIALS GRANT (This is the setup of oauth client which will use the client credentials grant type to obtain access token directly from the auth server. There is no resource owner here.):
https://docs.spring.io/spring-security/reference/servlet/oauth2/index.html#oauth2-client-access-protected-resources
The application requires at least one ClientRegistration to be configured.

spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: client_credentials
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token

The following example uses the default OAuth2AuthorizedClientManager to configure a RestClient capable of accessing protected resources by placing Bearer tokens in the Authorization header of each request:

@Configuration
public class RestClientConfig {
	@Bean
	public RestClient restClient(OAuth2AuthorizedClientManager authorizedClientManager) {
		OAuth2ClientHttpRequestInterceptor requestInterceptor =
				new OAuth2ClientHttpRequestInterceptor(authorizedClientManager);
		return RestClient.builder()
				.requestInterceptor(requestInterceptor)
				.build();
	}
}

This configured RestClient can be used as in the following example, to access protected resource:
import static org.springframework.security.oauth2.client.web.client.RequestAttributeClientRegistrationIdResolver.clientRegistrationId;

@RestController
public class MessagesController {
	private final RestClient restClient;

	public MessagesController(RestClient restClient) {
		this.restClient = restClient;
	}

	@GetMapping("/messages")
	public ResponseEntity<List<Message>> messages() {
		Message[] messages = this.restClient.get()
				.uri("http://localhost:8090/messages")
				.attributes(clientRegistrationId("my-oauth2-client"))
				.retrieve()
				.body(Message[].class);
		return ResponseEntity.ok(Arrays.asList(messages));
	}

	public record Message(String message) {
	}
}
-------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/oauth2/index.html#oauth2-client-access-protected-resources-current-user
Unlike the previous example, notice that we do not need to tell Spring Security about the clientRegistrationId we’d like to use. This is because it can be derived from the currently logged in user.

this.restClient.get()
				.uri("http://localhost:8090/messages")
				.attributes(clientRegistrationId("my-oauth2-client"))
				.retrieve()
				.body(Message[].class);
Here "clientRegistrationId" is used to tell restclient which client credentials to use to fetch the access token as there can be multiple client credentials configured in a spring boot app.
----------------------------------------------------------
If using Spring Boot with no additional customizations, we can actually omit the SecurityFilterChain bean entirely.
----------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/oauth2/client/core.html#oauth2Client-client-registration
This link has useful explanation of the client-registration object params.
----------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/oauth2/client/authorized-clients.html#oauth2-client-rest-client
"If an existing OAuth2AccessToken is expired, it is refreshed (or renewed)"

"The following example uses the default OAuth2AuthorizedClientManager to configure a RestClient capable of accessing protected resources by placing Bearer tokens in the Authorization header of each request"
--------------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/oauth2/client/authorized-clients.html#oauth2-client-rest-client-registration-id
--------------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/oauth2/login/core.html#oauth2login-common-oauth2-provider
CommonOAuth2Provider pre-defines a set of default client properties for a number of well known providers: Google, GitHub, Facebook, and Okta.
For example, the authorization-uri, token-uri, and user-info-uri do not change often for a provider. Therefore, it makes sense to provide default values, to reduce the required configuration.
As demonstrated previously, when we configured a Google client, only the client-id and client-secret properties are required.
---------------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html
By default, Spring Security requires that every request be authenticated. That said, any time you use an HttpSecurity instance, it’s necessary to declare your authorization rules.
Whenever you have an HttpSecurity instance, you should at least do:
http.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated())
----------------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html#authorizing-endpoints
AuthorizationFilter processes these pairs in the order listed, applying only the first match to the request.
@Bean
public SecurityFilterChain web(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests((authorize) -> authorize
	    .requestMatchers("/endpoint").hasAuthority("USER")
            .anyRequest().authenticated()
        )
        // ...

    return http.build();
}
The way to read the above rules is "if the request is /endpoint, then require the USER authority; else, only require authentication".
-----------------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html#match-requests
Spring Security supports two languages for URI pattern-matching: Ant (as seen above) and Regular Expressions.
You can also match rules by HTTP method. One place where this is handy is when authorizing by permissions granted, like being granted a read or write privilege.
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers(HttpMethod.GET).hasAuthority("read")
        .requestMatchers(HttpMethod.POST).hasAuthority("write")
        .anyRequest().denyAll()
    )
-----------------------------------------------------------------
https://docs.spring.io/spring-security/reference/servlet/authorization/authorize-http-requests.html#authorize-requests
-----------------------------------------------------------------
https://www.baeldung.com/spring-security-oauth-resource-server
If we need to start it independently, then we can supply the jwk-set-uri property instead to point to the authorization server’s endpoint exposing public keys:

https://docs.spring.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html#_startup_expectations
Check the flow of how resource server works. Also check about "provider configuration".

-----------------------------------------------------------------
Sample projects for spring security:
https://github.com/spring-projects/spring-security-samples
-----------------------------------------------------------------
Components of JWT token:
A JSON Web Token (JWT) is a single string of data composed of three parts, separated by dots (), which are the Header, the Payload, and the Signature.
Here is a breakdown of each component:

• Header: This is a JSON object containing metadata, such as the token type () and the signing algorithm (e.g., HS256, RS256). The header is then Base64url encoded.
• Payload: This JSON object, also called the JWT Claims Set, holds the data being transmitted. Claims can be registered (like issuer, subject, expiration), public (custom but collision-resistant), or private (custom for agreed-upon parties). The payload is Base64url encoded. Since it's only encoded and not encrypted, sensitive data should not be stored here.
• Signature: This part ensures the token's integrity and authenticity. It's generated using the encoded header, encoded payload, a secret key, and the specified algorithm. The signature is also Base64url encoded.

The final JWT is formed by combining these encoded parts with periods: . You can use tools like the one at jwt.io to explore JWT components.

-----------------------------------------------------------------
Jwt signature verification:
https://www.jwt.io/introduction#difference-decoding-encoding-jwt

Signature Verification: This is the primary aspect of verification where the signature part of the JWT is checked against the header and payload. This is done using the algorithm specified in the header (like HMAC, RSA, or ECDSA) with a secret key or public key. If the signature doesn't match what's expected, the token might have been tampered with or is not from a trusted source.



