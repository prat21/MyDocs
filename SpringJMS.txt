https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jms
https://www.oracle.com/technical-resources/articles/java/intro-java-message-service.html
-----------------------------------------------------------------------------------------------
Synchronous and Asynchronous Message Consumption:
A JMS client can consume messages either synchronously or asynchronously.

1. Synchronous: In this mode, a client receives a message by invoking the receive() method of the MessageConsumer object. The application thread blocks until the method returns, and this has the consequence that if a message is not available, it blocks until a message becomes available or the receive() method times out. Also, note that in this model the client can consume one message at a time.
2. Asynchronous: In this mode, the client registers a MessageListener object with a message consumer. This is like a call-back where the client consumes a message when the session invokes the onMessage() method. In other words, the application's thread doesn't block.

-----------------------------------------------------------------------------------------------
The MessagePostProcessor interface gives you access to the message after it has been converted but before it is sent

public class JmsSenderWithConversion {

	private JmsTemplate jmsTemplate;

	public void sendWithConversion() {
		Map<String, Object> map = new HashMap<>();
		map.put("Name", "Mark");
		map.put("Age", 47);
		jmsTemplate.convertAndSend("testQueue", map, new MessagePostProcessor() {
			public Message postProcessMessage(Message message) throws JMSException {
				message.setIntProperty("AccountID", 1234);
				message.setJMSCorrelationID("123-00001");
				return message;
			}
		});
	}

}
-----------------------------------------------------------------------------------------------
JmsClient:
https://docs.spring.io/spring-framework/reference/integration/jms/sending.html#jms-sending-jmsclient
-----------------------------------------------------------------------------------------------
Synchronous Message Consumption:
https://docs.spring.io/spring-framework/reference/integration/jms/receiving.html#jms-receiving-sync
While JMS is typically associated with asynchronous processing, you can consume messages synchronously. The receive(..) methods on JmsTemplate and JmsClient provide this functionality. During a synchronous receive, the calling thread blocks until a message becomes available.
-----------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/integration/jms/annotated.html#jms-annotated-response
-----------------------------------------------------------------------------------------------
MessageListenerAdapter: An adapter that implements the MessageListener interface, delegating the handling of messages to target listener methods via reflection. This is an example of adapter design pattern.
https://docs.spring.io/spring-framework/reference/integration/jms/receiving.html#jms-receiving-async-message-listener-adapter
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jms/listener/adapter/MessageListenerAdapter.html
Notice how the message handling method is actually called "receive" (the name of the message handling method in a MessageListenerAdapter defaults to "handleMessage"), but it is configurable.
-----------------------------------------------------------------------------------------------
Message Listener Containers:
https://docs.spring.io/spring-framework/reference/integration/jms/using.html#jms-mdp
-----------------------------------------------------------------------------------------------
Asynchronous Message Consumption:
https://docs.spring.io/spring-framework/reference/integration/jms/receiving.html#jms-receiving-async
-----------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/integration/jms/receiving.html#jms-tx-participation
"You can activate local resource transactions through the sessionTransacted flag on the listener container definition. Each message listener invocation then operates within an active JMS transaction, with message receipt rolled back in case of listener execution failure."

"To configure a message listener container for XA transaction participation, you want to configure a JtaTransactionManager (which, by default, delegates to the Jakarta EE serverâ€™s transaction subsystem). Note that the underlying JMS ConnectionFactory needs to be XA-capable and properly registered with your JTA transaction coordinator. This lets message receipt as well as (for example) database access be part of the same transaction."

@Bean
DefaultMessageListenerContainer jmsContainer(ConnectionFactory connectionFactory, Destination destination,
		ExampleListener messageListener) {

	DefaultMessageListenerContainer jmsContainer = new DefaultMessageListenerContainer();
	jmsContainer.setConnectionFactory(connectionFactory);
	jmsContainer.setDestination(destination);
	jmsContainer.setMessageListener(messageListener);
	jmsContainer.setSessionTransacted(true);
	return jmsContainer;
}

Note: See distributed transaction management for more information on JTA and XA transactions.
-----------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/integration/jms/annotated.html
"To enable support for @JmsListener annotations, you can add @EnableJms to one of your @Configuration classes, as the following example shows:"

@Configuration
@EnableJms
public class JmsConfiguration {

	@Bean
	public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(ConnectionFactory connectionFactory,
			DestinationResolver destinationResolver) {

		DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
		factory.setConnectionFactory(connectionFactory);
		factory.setDestinationResolver(destinationResolver);
		factory.setSessionTransacted(true);
		factory.setConcurrency("3-10");
		return factory;
	}
}

By default, the infrastructure looks for a bean named jmsListenerContainerFactory as the source for the factory to use to create message listener containers. In this case, you can invoke the processOrder method with a core pool size of three threads and a maximum pool size of ten threads.

So far, we have been injecting a simple String in our endpoint, but it can actually have a very flexible method signature. In the following example, we rewrite it to inject the Order with a custom header:

@Component
public class MyService {

	@JmsListener(destination = "myDestination")
	public void processOrder(Order order, @Header("order_type") String orderType) {
		...
	}
}

https://docs.spring.io/spring-framework/reference/integration/jms/annotated.html#jms-annotated-response
"The existing support in MessageListenerAdapter already lets your method have a non-void return type. When that is the case, the result of the invocation is encapsulated in a jakarta.jms.Message, sent either in the destination specified in the JMSReplyTo header of the original message or in the default destination configured on the listener. You can now set that default destination by using the @SendTo annotation of the messaging abstraction."
"The annotated endpoint infrastructure creates a message listener container behind the scenes for each annotated method,by using a JmsListenerContainerFactory."

@JmsListener(destination = "myDestination")
@SendTo("status")
public OrderStatus processOrder(Order order) {
	// order processing
	return status;
}

"Finally, if you need to specify some QoS values for the response such as the priority or the time to live, you can configure the JmsListenerContainerFactory accordingly, as the following example shows:"

@Configuration
@EnableJms
public class AppConfig {

	@Bean
	public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
		DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
		factory.setConnectionFactory(connectionFactory());
		QosSettings replyQosSettings = new QosSettings();
		replyQosSettings.setPriority(2);
		replyQosSettings.setTimeToLive(10000);
		factory.setReplyQosSettings(replyQosSettings);
		return factory;
	}
}
-----------------------------------------------------------------------------------------------