In comparable docs of oracle:-

All other things being equal, immutable types are the way to go, especially for objects that will be used as elements in Sets or as keys in Maps. These collections will break if you modify their elements or keys while they're in the collection.

See: https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html

If you try to sort a list, the elements of which do not implement Comparable, Collections.sort(list) will throw a ClassCastException. Similarly, Collections.sort(list, comparator) will throw a ClassCastException if you try to sort a list whose elements cannot be compared to one another using the comparator.

There are four restrictions on the behavior of the compareTo method, which we won't go into now because they're fairly technical and boring and are better left in the API documentation. It's really important that all classes that implement Comparable obey these restrictions, so read the documentation for Comparable if you're writing a class that implements it. Attempting to sort a list of objects that violate the restrictions has undefined behavior. Technically speaking, these restrictions ensure that the natural ordering is a total order on the objects of a class that implements it; this is necessary to ensure that sorting is well defined.

https://en.wikipedia.org/wiki/Total_order

The compare method has to obey the same four technical restrictions as Comparable's compareTo method for the same reason â€” a Comparator must induce a total order on the objects it compares.

The Comparator in the preceding program works fine for sorting a List, but it does have one deficiency: It cannot be used to order a sorted collection, such as TreeSet, because it generates an ordering that is not compatible with equals. This means that this Comparator equates objects that the equals method does not. In particular, any two employees who were hired on the same date will compare as equal. When you're sorting a List, this doesn't matter; but when you're using the Comparator to order a sorted collection, it's fatal. If you use this Comparator to insert multiple employees hired on the same date into a TreeSet, only the first one will be added to the set; the second will be seen as a duplicate element and will be ignored.

To fix this problem, simply tweak the Comparator so that it produces an ordering that is compatible with equals. In other words, tweak it so that the only elements seen as equal when using compare are those that are also seen as equal when compared using equals. The way to do this is to perform a two-part comparison (as for Name), where the first part is the one we're interested in â€” in this case, the hire date â€” and the second part is an attribute that uniquely identifies the object. Here the employee number is the obvious attribute. This is the Comparator that results.

-----------------------------------------------------------------------------------------------------------------
https://www.google.com/url?sa=i&source=imgres&cd=&cad=rja&uact=8&ved=2ahUKEwiolLSj7PPcAhUFtI8KHUpKBOMQjRx6BAgBEAU&url=https%3A%2F%2Fwww.edureka.co%2Fblog%2Fjava-collections%2F&psig=AOvVaw2v1Ntbjz1gp_Mg8n8s0Peb&ust=1534587020563491 (Collection Image)

1. How Hashset Works?

http://www.java67.com/2014/01/how-hashset-is-implemented-or-works-internally-java.html

A hashset is internally backed up by a hashmap. If we are to add an object K to the set, then the pair <K,Constant> is put into the backing map. Since the existing structure of the map does not allow duplicate keys,hence this behavior has been used to create hashset.


2. How HashMap works?

https://javarevisited.blogspot.com/2011/02/how-hashmap-works-in-java.html

Hashmap maintains an array of linked list to store its elements. While inserting a key value pair K,V; it calculates the hash of the key K (If K is an object then it computes the hashcode() method of that object) and according to that hashcode generates an index and puts the pair in that bucket (or array position). Since the size of the array is limited, it may so happen that two different hashcodes map to the same index, ie hash collision. In that case, the new pair will inserted as a new node in the linked list of that index of the array (Internally, the node present in the ith index of the array stores the reference of the new node, thus maintaining a link to the new node). While placing the new node, the hashmap checks whether the key already exists or not in that linked list by using the equals() method of the object K (Since Keys are unique in hashmap).

Kindly note that the node stores the key,value,hashcode as well as reference to the next node (if any).

The keyset() method returns the set of keys by iterating through the array. The iteration happens over the entire array, regardless of whether a particular array entry contains elements or not.

http://www.baeldung.com/java-hashmap (Read this, its nice)
https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html

This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the "capacity" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.

As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.

https://www.baeldung.com/java-hashmap#capacity-load-factor
To avoid having many buckets with multiple values, the capacity is doubled if 75% (the load factor) of the buckets become non-empty. The default value for the load factor is 75%, and the default initial capacity is 16. Both can be set in the constructor.

The keyset() method creates a set of keys of the hashmap backed by the map itself, ie any changes in the map is reflected in the keyset and vice-versa.

One of the practical example of abstract class is HashIterator in HashMap(check source code of hashmap). The HashIterator is extended by KeyIterator,ValueIterator and EntryIterator.

3. How LinkedHashMap works?

The LinkedHashMap class is very similar to HashMap in most aspects. However, the linked hash map is based on both hash table and linked list to enhance the functionality of hash map.

It maintains a doubly-linked list running through all its entries in addition to an underlying array of default size 16.

To maintain the order of elements, the linked hashmap modifies the Map.Entry class of HashMap by adding pointers to the next and previous entries.

LinkedHashMap provides a special constructor which enables us to specify, among custom load factor (LF) and initial capacity, a different ordering mechanism/strategy called access-order:

LinkedHashMap<Integer, String> map = new LinkedHashMap<>(16, .75f, true);

The first parameter is the initial capacity, followed by the load factor and the last param is the ordering mode. So, by passing in true, we turned out access-order, whereas the default was insertion-order.

This mechanism ensures that the order of iteration of elements is the order in which the elements were last accessed, from least-recently accessed to most-recently accessed.

And so, building a Least Recently Used (LRU) cache is quite easy and practical with kind of a map.

The difference with HashMap lies in what entails a structural modification. In access-ordered (in which access-order is the ordering mechanism) linked hash maps, merely calling the get API results in a structural modification. Alongside this, are operations like put and remove.

Naturally, iteration over a view of the map doesâ€™t affect the order of iteration of the backing map; only explicit access operations on the map will affect the order.

Iteration over collection views of LinkedHashMap also takes linear time O(n) similar to that of HashMap. On the flip side, LinkedHashMapâ€˜s linear time performance during iteration is better than HashMapâ€˜s linear time.

This is because, for LinkedHashMap, n in O(n) is only the number of entries in the map regardless of the capacity. Whereas, for HashMap, n is capacity and the size summed up, O(size+capacity).

http://www.baeldung.com/java-linked-hashmap

4. How TreeMap works?

Unlike LinkedHashMap and HashMap, TreeMap does not use hashing for storing keys. It uses a data structure called Red-Black tree.

https://www.baeldung.com/java-treemap

By default, TreeMap sorts all its entries according to their natural ordering. For an integer, this would mean ascending order and for strings, alphabetical order. TreeMap, unlike a hash map and linked hash map, does not employ the hashing principle anywhere since it does not use an array to store its entries.

TreeMap implements NavigableMap interface and bases itâ€™s internal working on the principles of red-black trees:

The principle of red-black trees is beyond the scope of this article, however, there are key things to remember in order to understand how they fit into TreeMap.

First of all, a red-black tree is a data structure that consists of nodes; picture an inverted mango tree with its root in the sky and the branches growing downward. The root will contain the first element added to the tree.

The rule is that starting from the root, any element in the left branch of any node is always less than the element in the node itself. Those on the right are always greater (Properties of a binary search tree). What defines greater or less than is determined by the natural ordering of the elements or the defined comparator at construction as we saw earlier.

This rule guarantees that the entries of a treemap will always be in sorted and predictable order.

Secondly, a red-black tree is a self-balancing binary search tree. This attribute and the above guarantee that basic operations like search, get, put and remove take logarithmic time O(log n).

Being self-balancing is key here. As we keep inserting and deleting entries, picture the tree growing longer on one edge or shorter on the other.

This would mean that an operation would take a shorter time on the shorter branch and longer time on the branch which is furthest from the root, something we would not want to happen.

Therefore, this is taken care of in the design of red-black trees. For every insertion and deletion, the maximum height of the tree on any edge is maintained at O(log n) i.e. the tree balances itself continuously.

Just like hash map and linked hash map, a tree map is not synchronized and therefore the rules for using it in a multi-threaded environment are similar to those in the other two map implementations.

Important: Since treemap is red-black tree, iterating over treemap means printing the elements of the red-black tree in sorted order. This takes O(nlogn) time which is more than the iteration time of hashmap which is O(n). On the other side, the time taken for the operations like containsKey takes O(logn) time which less than that of the hashmap (Wrong, containsKey is just another get() operation which takes O(1) time to run). The only reason we would want to have treemap instead of hashmap, is when we want the keys to be in a sorted order. Otherwise runtime of all the operations is better in hashmap.


5. LinkedHashSet:

Performance is likely to be just slightly below that of HashSet, due to the added expense of maintaining the linked list, with one exception: Iteration over a LinkedHashSet requires time proportional to the size of the set, regardless of its capacity. Iteration over a HashSet is likely to be more expensive, requiring time proportional to its capacity.

Since hashset is backed up by a hashmap, it stores its elements in an array of linked list. Due to hashing, it may so happen that there are some array indices which are empty or null. While iterating, hashset traverses over the entire array and checks whether a value for a particular index is null or not. If not, then it returns it otherwise it ignores it. For this reason, iterating over a hashset is quite expensive.

Linkedhashset on the other hand maintains a doubly linkedlist of the elements in the order in which it was inserted. Hence while iterating, the linkedhashset only need to traverse over the linked list ie its total capacity. Therefore it has less expensive iteration time.

https://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html

LinkedHashSet maintains two kind of links or references. One link is to maintain the insertion order linked list and the other is to maintain the linked list of a particular bucket (or array index).

http://javaconceptoftheday.com/how-linkedhashset-works-internally-in-java/

LinkedHashSet uses LinkedHashMap object to store itâ€™s elements. In LinkedHashMap, the same set of Entry objects (rather references to Entry objects) are arranged in two different manner. One is the HashMap and another one is Doubly linked list. The Entry objects just sit on heap memory, unaware of that they are part of two different data structures.

-----------------------------------------------------------------------------------------------------------------

Differences between TreeMap, HashMap and LinkedHashMap in Java:

https://www.geeksforgeeks.org/differences-treemap-hashmap-linkedhashmap-java/

-----------------------------------------------------------------------------------------------------------------
See Queue Interface first

6) PriorityQueue:

A priority queue does not permit null elements. The head of this queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily. The queue retrieval operations poll, remove, peek, and element access the element at the head of the queue.

Implementation note: this implementation provides O(log(n)) time for the enqueing and dequeing methods (Since enqueing and dequeing of a binary heap takes O(logn) time) (offer, poll, remove() and add); linear time for the remove(Object) and contains(Object) methods; and constant time for the retrieval methods (peek, element, and size).

https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html

Priority queue is implemented by an array (see algorithms book).

LinkedList implements Queue interface and applies FIFO rule. Also it implements Dequeue interface, since elements can be accessed from both ends.



7) Dequeue interface:

A linear collection that supports element insertion and removal at both ends. This interface defines methods to access the elements at both ends of the deque. Methods are provided to insert, remove, and examine the element. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation).

This interface extends the Queue interface. When a deque is used as a queue, FIFO (First-In-First-Out) behavior results. Elements are added at the end of the deque and removed from the beginning. 

Deques can also be used as LIFO (Last-In-First-Out) stacks. This interface should be used in preference to the legacy Stack class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque. 

This interface provides two methods to remove interior elements, removeFirstOccurrence and removeLastOccurrence.

Unlike the List interface, this interface does not provide support for indexed access to elements.

While Deque implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any Deque implementations that do allow null elements are strongly encouraged not to take advantage of the ability to insert nulls. This is so because null is used as a special return value by various methods to indicated that the deque is empty.

https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html



-----------------------------------------------------------------------------------------------------------------


8) Arraylist:

Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)

The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation.

What is amortized constant time: https://stackoverflow.com/questions/200384/constant-amortized-time

9) LinkedList:

Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).
All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.

Arraylist vs linkedlist
https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist-in-java

-----------------------------------------------------------------------------------------------------------------
List vs Queue:

List provides random access/addition/removal of elements through indexed access, whereas queue allows access/addition/removal only through one or two ends (head or tail).

List can be used as FIFO queue, if we use the standard add() and remove() methods of Collection interface. Because "add()" method adds at the end(tail) of the list (equivalent to addLast() mehod) and "remove()" method removes from the beginning(head) of the list (equivalent to removeFirst() mehod).

If the List is used as stack data structure (LIFO), then there are pre-defined push(E e) and pop() methods. The push(E e) method inserts the element at the head of the list and pop() removes the element from the head of the list (equivalent to addFirst(E e) and removeFirst() methods).
-----------------------------------------------------------------------------------------------------------------

ConcurrentHashMap:

https://www.geeksforgeeks.org/concurrenthashmap-in-java/
https://www.geeksforgeeks.org/difference-hashmap-concurrenthashmap/
In Hashmap null values are allowed for keys and values, but in concurrenthashmap null value is not allowed for key or value.
http://www.java67.com/2012/08/difference-between-hashmap-and-concurrentHashMap-java-collection.html
https://stackoverflow.com/questions/12646404/concurrenthashmap-and-hashtable-in-java
https://www.geeksforgeeks.org/differences-between-hashmap-and-hashtable-in-java/
-----------------------------------------------------------------------------------------------------------------

CopyOnWriteArrayList:

A thread-safe variant of ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array.

This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads. The "snapshot" style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. The iterator will not reflect additions, removals, or changes to the list since the iterator was created.

Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException.

All elements are permitted, including null.

https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html
https://www.geeksforgeeks.org/copyonwritearraylist-in-java/
https://www.baeldung.com/java-copy-on-write-arraylist
-----------------------------------------------------------------------------------------------------------------

Difference between iterator and enumeration:

https://javaconceptoftheday.com/differences-between-enumeration-vs-iterator-in-java/

All Collection types maintain an internal array of objects ( Object[] ) to store the elements.
Fail-Fast iterators directly fetch the elements from this array.
They always consider that this internal array is not modified while iterating over its elements.
To know whether the collection is modified or not, they use an internal flag called modCount which is updated each time a collection is modified.
Every time when an Iterator calls the next() method, it checks the modCount.
If it finds the modCount has been updated after this Iterator has been created, it throws ConcurrentModificationException.

https://javaconceptoftheday.com/fail-fast-and-fail-safe-iterators-in-java-with-examples/
https://www.baeldung.com/java-fail-safe-vs-fail-fast-iterator
https://javaconceptoftheday.com/difference-between-iterator-and-listiterator-in-java/

Iterators on Collections from java.util.concurrent package such as ConcurrentHashMap, CopyOnWriteArrayList, etc. are Fail-Safe in nature.
The default iterator for the ConcurrentHashMap is weakly consistent. This means that this Iterator can tolerate concurrent modification, traverses elements as they existed when Iterator was constructed and may (but isn't guaranteed to) reflect modifications to the Collection after the construction of the Iterator.

-----------------------------------------------------------------------------------------------------------------

AutoCloseable interface and try-with-resources in java 7:

In try-with-resources method there is no use of finally block. the file resource is opened in try block inside small brackets. Only the objects of those classes can be opened within the block which implements AutoCloseable interface and those object should also be local. The resource will be closed automatically regardless of whether try statement completes normally or abruptly.

Multiple resources can be used inside a try-with-resources block and have them all automatically closed. In this case, the resources will be closed in the reverse order in which they were created inside the brackets.

When we open any such AutoCloseable resource in special try-with-resource block, immediately after finishing the try block, JVM calls this.close() method on all resources initialized in try block.

Note: A try-with-resources statement can have catch and finally blocks just like an ordinary try statement. In a try-with-resources statement, any catch or finally block is run after the resources declared have been closed.

https://www.geeksforgeeks.org/automatic-resource-management-java/
https://www.baeldung.com/java-suppressed-exceptions

When using try-catch-finally block, the exception thrown from the try gets suppressed by the exception thrown from finally.
When using AutoCloseable, it's the exception thrown in the close method of try-with-resource that's suppressed.
A resource that we use in try-with-resource must be subtypes of AutoCloseable to avoid a compile-time error.

-----------------------------------------------------------------------------------------------------------------
Difference between iterator and listiterator:

Here are the differences between them:

With iterator you can move only forward, but with ListIterator you can move backword also while reading the elements.
With ListIterator you can obtain the index at any point while traversing, which is not possible with iterators.
With iterator you can check only for next element available or not, but in listiterator you can check previous and next elements.
With listiterator you can add new element at any point of time, while traversing. Not possible with iterator.

https://stackoverflow.com/questions/10977992/difference-between-iterator-and-listiterator
https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html

-----------------------------------------------------------------------------------------------------------------
Classloader:

http://www.baeldung.com/java-classloaders

https://www.journaldev.com/349/java-classloader

https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html

Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.

Check the documentation in the source code of Classloader.java.

Check the doc of "loadClass(String name, boolean resolve)" method in Classloader.java. It explains the steps on how a class is loaded in memory.
"Loads the class with the specified binary name. The default implementation of this method searches for classes in the following order:
1. Invoke findLoadedClass(String) to check if the class has already been loaded.
2. Invoke the loadClass method on the parent class loader. If the parent is null the class loader built into the virtual machine is used, instead.
3. Invoke the findClass(String) method to find the class."

CHATGPT for what is classloader:
What is a ClassLoader?
In Java, a ClassLoader is a part of the Java Runtime Environment (JRE) responsible for loading classes into memory at runtime.
Java programs are compiled into bytecode, which is stored in .class files. The ClassLoader loads these .class files when they're needed by the Java Virtual Machine (JVM).

ðŸ”§ Key Responsibilities:
1. Loading classes from the file system, network, or other sources.
2. Defining the namespace for classes (i.e., separating classes loaded by different class loaders).
3. Delegation â€“ ClassLoaders typically follow a parent-delegation model to avoid class conflicts and ensure consistency.

ðŸ”„ Types of ClassLoaders in Java:
ClassLoader	Description
1. Bootstrap ClassLoader:	Loads core Java classes (from rt.jar, e.g., java.lang.*). Part of JVM, written in native code.
2. Extension ClassLoader:	Loads classes from JAVA_HOME/lib/ext or any extension directories.
3. System/Application ClassLoader:	Loads classes from the application classpath (e.g., your own .class files or libraries).
4. Custom ClassLoaders:	You can create your own by extending ClassLoader. Useful for modular applications or plugin systems.

ðŸ§  How it Works: Parent Delegation Model
When a ClassLoader is asked to load a class:
1. It first delegates the request to its parent.
2. If the parent cannot find the class, the current ClassLoader attempts to load it.
Why:
1. Security
Prevents malicious or accidental overriding of core Java classes (like java.lang.String) by custom classes.
For example, a user-defined class named java.lang.String won't be loaded because the Bootstrap ClassLoader (the top parent) loads Java core libraries first.

2. Avoids Duplication
Ensures classes are loaded only once in the JVM by the most appropriate loader.
Prevents ClassCastException and ClassNotFoundException due to multiple copies of the same class.

3. Maintains Consistency
Core Java classes are always loaded by trusted system class loaders.
Ensures uniform behavior across all Java applications.

4. Performance Optimization
Delegating to a parent avoids redundant disk or network lookups if a class has already been loaded higher up the chain.

Use Cases for Custom ClassLoaders:
1. Dynamic loading of plugins or modules.
2. Hot reloading classes at runtime.
3. Isolation of different components (e.g., in app servers or IDEs).

Check CHATGPT on Custom classloader example:

-----------------------------------------------------------------------------------------------------------------
Ways to create objects in java:
https://www.geeksforgeeks.org/different-ways-create-objects-java/

For cloning and deserialization, JVM does not use constructor.

-----------------------------------------------------------------------------------------------------------------
 
 BlockingQueue:
 
 https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html
 
 https://www.journaldev.com/1034/java-blockingqueue-example
 
A BlockingQueue may be capacity bounded. At any given time it may have a remainingCapacity beyond which no additional elements can be put without blocking. A BlockingQueue without any intrinsic capacity constraints always reports a remaining capacity of Integer.MAX_VALUE.

Check the implementation logic of ArrayBlockingQueue, especially put and take methods. Also check the reentrantLock and Condition objects.
 
-----------------------------------------------------------------------------------------------------------------
 
 Difference between Abstract Class and Interface in Java
 
 https://www.geeksforgeeks.org/difference-between-abstract-class-and-interface-in-java/
 https://stackoverflow.com/questions/1913098/what-is-the-difference-between-an-interface-and-abstract-class?page=1&tab=votes#tab-top

From Java 8, interfaces can have default and static methods with concrete implementations.From Java 9, interfaces can also have private methods.
Variables declared in an interface are by default public, static, and final (constants).

One of the practical example of abstract class is HashIterator in HashMap(check source code of hashmap). The HashIterator is extended by KeyIterator,ValueIterator and EntryIterator.

Look in ChatGPT as well.
 
-----------------------------------------------------------------------------------------------------------------
Types of memory space allocated in java:
https://www.baeldung.com/java-stack-heap
https://www.geeksforgeeks.org/how-many-types-of-memory-areas-are-allocated-by-jvm/

Note: The "method area" is same as permgen/metaspace.
Method Area (MetaSpace in Java 8+)
1. Purpose: Stores class metadata, static variables, method bytecode, etc.
2. Was part of PermGen in Java â‰¤7, replaced by MetaSpace in Java 8.
3. Shared across all threads.

Check in ChatGPT for summary.
-----------------------------------------------------------------------------------------------------------------
Garbage Collection in Java:

https://www.geeksforgeeks.org/garbage-collection-java/
1. finalize() method is deprecated since Java 9 because it is unpredictable and can cause performance issues.
2. Alternatives like try-with-resources or explicit cleanup methods are preferred.
3. The garbage collector calls finalize() at most once per object.
4. Exceptions thrown in finalize() are ignored.

Island of isolation:
https://www.geeksforgeeks.org/island-of-isolation-in-java/

Garbage Collection Process:
1. https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html
(See "Describing Garbage Collection" and "The Generational Garbage Collection Process")
(Also check the JVM architecture, "Performance Basics" and "Java Garbage Collectors")
"Performance Basics" explains latency and throughput.
Basically the lower the GC pause, the lower is the latency. High GC pauses(for example Serial and Parallel GCs) means high latency.
Throughput is measured by the time spent doing garbage collection versus the time spent outside of garbage collection, referred to as application time. Parallel GC is called throughput GC because it takes much less time to do garbage collection(during GC pauses) since it uses multiple threads.
2. Also See: https://www.youtube.com/watch?v=5wkzEy_BXdA (It has good explanation of garbage collectors)
3. https://docs.oracle.com/en/java/javase/21/gctuning/parallel-collector1.html
4. https://www.baeldung.com/jvm-garbage-collectors

Garbage Collectors:
1. Parallel collector:
The Parallel collector is also called a throughput collector. Since it can use multilple CPUs to speed up application throughput. This collector should be used when a lot of work need to be done and long pauses are acceptable. For example, batch processing like printing reports or bills or performing a large number of database queries. Default collector up until java 8.

2. G1 garbage collector:
Some operations are always performed in stop-the-world pauses to improve throughput. Other operations that would take more time with the application stopped such as whole-heap operations like global marking are performed in parallel and concurrently with the application. Default collector from java 9.

3. Z garbage collector:
The Z garbage collector is a scalable, low latency garbage collector. ZGC performs all expensive work concurrently, without stopping the execution of application threads for more than a millisecond.
ZGC provides max pause times under millisecond, but at the cost of same throughput. It is intended for applications, which required low latency. Pause times are independent of heap size that is being used. ZGC works well for heap sizes from a few hundred megabytes to 16TB.
ZGC Generational collection is possible since java 21. But still not the default collector. Default is still G1.

GC Command line options:
The minimum and maximum heap sizes that the garbage collector can use can be set using -Xms and -Xmx respectively.
Command line options:
-Xms
-Xmx
-XX:+UseParallelGC
-XX:ParallelGCThreads
The maximum pause time goal is specified with the command-line option -XX:MaxGCPauseMillis
Specify throughput goal -XX:GCTimeRatio
-XX:+UseG1GC
Example: java -Xmx12m -Xms3m -XX:+UseParallelGC -jar <JAR_FILE>

Achieve high GC throughput:
https://medium.com/@RamLakshmanan/how-to-achieve-high-gc-throughput-2a5405417d95 (Check "Reasons for poor garbage collection throughput", along with the rest)

https://stackoverflow.com/questions/39687702/why-g1-gives-better-pause-time-but-lower-throughput
G1 garbage collector uses concurrently marking live objects but stop-the-world cleanup dead objects. So, the pause time is shorter than stop-the-world GC (e.g. Parallel Scavenge), but longer time to do GC as less resources to do concurrent marking live objects and additional time needed to do remarking live objects (the objects changed during the concurrent marking phase).

https://stackoverflow.com/questions/72290017/when-not-to-use-g1gc-garbage-collector
1. If you have absolutely no interest in GC pause times, then use the serial collector (if you only have one core) or the parallel collector (if you have more than one core).
2. If you need low pause times (with high probability), then use the G1 collector.
3. If you need ultra-low pause times, and/or you have an extremely large heap, use the Z collector.
4. The old CMS collector has been removed as of Java 14.
-----------------------------------------------------------------------------------------------------------------
"The Permanent generation contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. In addition, Java SE library classes and methods may be stored here."

https://www.baeldung.com/java-string-pool (It has good explanation of String pool and garbage collection)
https://www.baeldung.com/java-string-immutable
https://www.baeldung.com/java-string-interview-questions
https://www.baeldung.com/java-9-compact-string

Whenever we create a string  if "all" the characters of the string can be represented using a byte - LATIN-1 representation, a byte array will be used internally, such that one byte is given for one character.
In other cases, if "any" character requires more than 8-bits to represent it, all the characters are stored using two bytes for each - UTF-16 representation.

https://docs.oracle.com/javase/8/docs/technotes/guides/vm/enhancements-7.html
Area: HotSpot
Standard/Platform: JDK 7
Synopsis: In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the String.intern() method will see more significant differences.
RFE: 6962931

Before Java 7, the JVM placed the Java String Pool in the PermGen space, which has a fixed size â€” it canâ€™t be expanded at runtime and is not eligible for garbage collection.

The risk of interning Strings in the PermGen (instead of the Heap) is that we can get an OutOfMemory error from the JVM if we intern too many Strings.

From Java 7 onwards, the Java String Pool is stored in the main heap space(not in permgen or metaspace), which is garbage collected by the JVM. The advantage of this approach is the reduced risk of OutOfMemory error because unreferenced Strings will be removed from the pool, thereby releasing memory.

-----------------------------------------------------------------------------------------------------------------

Methods in object class:

wait(),notify(),notifyall(),
equals(),hashcode(),tostring(),
clone(),finalize(),getclass()

-----------------------------------------------------------------------------------------------------------------

concurrenthashmap vs hashtable:

https://stackoverflow.com/questions/12646404/concurrenthashmap-and-hashtable-in-java

ConcurrentHashMap uses multiple buckets to store data. This avoids read locks and greatly improves performance over a HashTable. Both are thread safe, but there are obvious performance wins with ConcurrentHashMap.

When you read from a ConcurrentHashMap using get(), there are no locks, contrary to the HashTable for which all operations are simply synchronized. HashTable was released in old versions of Java whereas ConcurrentHashMap is a java 5+ thing.

-----------------------------------------------------------------------------------------------------------------

JDBC:

https://www.javatpoint.com/jdbc-driver
https://www.geeksforgeeks.org/jdbc-drivers/


Q: Why we use Class.forName() while connecting to a database?
A: https://stackoverflow.com/questions/20078586/why-we-use-class-forname-oracle-jdbc-driver-oracledriver-while-connecting-to

Q: Difference between class.forname and new keyword?
A: https://stackoverflow.com/questions/4612386/what-is-the-difference-between-the-new-operator-and-class-newinstance
Also check chatGPT.

Java Database Connectivity with 5 Steps:

There are 5 steps to connect any java application with the database using JDBC. These steps are as follows:
1. Register the driver class (Note: Since JDBC 4.0, explicitly registering the driver is optional. We just need to put vender's Jar in the classpath, and then JDBC driver manager can detect and load the driver automatically. See the above link for more details.)
2. Creating connection
3. Creating statement
4. Executing queries
5. Closing connection (Note: Since Java 7, JDBC has ability to use try-with-resources statement to automatically close resources of type Connection, ResultSet, and Statement.)


	Connection conn = null;
	Statement stmt = null;
   try{
      //STEP 1: Register JDBC driver
      Class.forName("com.mysql.jdbc.Driver");

      //STEP 2: Open a connection
      conn = DriverManager.getConnection(DB_URL,USER,PASS);

      //STEP 3: Creating statement
      stmt = conn.createStatement();
      String sql;
      sql = "SELECT id, first, last, age FROM Employees";
	  
	  //STEP 4: Executing queries
      ResultSet rs = stmt.executeQuery(sql);

      while(rs.next()){
         int id  = rs.getInt("id");
         int age = rs.getInt("age");
         String first = rs.getString("first");
         String last = rs.getString("last");
      }
      //STEP 5: Clean-up environment
      rs.close();
      stmt.close();
      conn.close();
   }catch(SQLException se){
      se.printStackTrace();
   }catch(Exception e){
      e.printStackTrace();
   }finally{
      try{
         if(stmt!=null)
            stmt.close();
      }catch(SQLException se2){
      }
      try{
         if(conn!=null)
            conn.close();
      }catch(SQLException se){
         se.printStackTrace();
      }
   }

   
JDBC connection URL for Oracle: "jdbc:oracle:thin:@hostname:portNumber:databaseName"

JDBC - Statements, PreparedStatement and CallableStatement:

Interfaces			Recommended Use
1.Statement			Use the for general-purpose access to your database. Useful when you are using static SQL statements at runtime. The Statement interface cannot accept parameters.
2.PreparedStatement	Use the when you plan to use the SQL statements many times. The PreparedStatement interface accepts input parameters at runtime.
3.CallableStatement	Use the when you want to access the database stored procedures. The CallableStatement interface can also accept runtime input parameters.

See : https://www.tutorialspoint.com/jdbc/jdbc-statements.htm


Once you've created a Statement object, you can then use it to execute an SQL statement with one of its three execute methods:

1. boolean execute (String SQL): Returns a boolean value of true if a ResultSet object can be retrieved; otherwise, it returns false. Use this method to execute SQL DDL statements or when you need to use truly dynamic SQL.

2. int executeUpdate (String SQL): Returns the number of rows affected by the execution of the SQL statement. Use this method to execute SQL statements for which you expect to get a number of rows affected - for example, an INSERT, UPDATE, or DELETE statement.

3. ResultSet executeQuery (String SQL): Returns a ResultSet object. Use this method when you expect to get a result set, as you would with a SELECT statement.

Call an execute statement: executeQuery if the query returns only one ResultSet (such as a SELECT SQL statement), executeUpdate if the query does not return a ResultSet (such as an UPDATE SQL statement), or execute if the query might return more than one ResultSet object.

Advantages of a PreparedStatement:

Precompilation and DB-side caching of the SQL statement leads to overall faster execution and the ability to reuse the same SQL statement in batches.

Automatic prevention of SQL injection attacks by builtin escaping of quotes and other special characters. Note that this requires that you use any of the PreparedStatement setXxx() methods to set the values

The main feature of a PreparedStatement object is that, unlike a Statement object, it is given a SQL statement when it is created.
The advantage to this is that in most cases, this SQL statement is sent to the DBMS right away, where it is compiled.
As a result, the PreparedStatement object contains not just a SQL statement, but a SQL statement that has been precompiled.
This means that when the PreparedStatement is executed, the DBMS can just run the PreparedStatement SQL statement without having to compile it first.

https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html
https://stackoverflow.com/questions/3271249/difference-between-statement-and-preparedstatement


-----------------------------------------------------------------------------------------------------------------

See difference between association, composition and aggregation in java
https://javarevisited.blogspot.com/2014/02/ifference-between-association-vs-composition-vs-aggregation.html
https://www.baeldung.com/java-composition-aggregation-association (Note how to model composition(using non-static inner class) and aggregation(separate class) in java)
https://www.baeldung.com/java-inheritance-composition

See - Composition is also very much preferred in object-oriented design over inheritance

https://javarevisited.blogspot.com/2013/06/why-favor-composition-over-inheritance-java-oops-design.html

The below link has very nice explanation on how java inheritance is fragile.
https://blogs.oracle.com/javamagazine/post/java-inheritance-composition
-----------------------------------------------------------------------------------------------------------------

Reflection:
https://www.geeksforgeeks.org/reflection-in-java/
https://www.oracle.com/technical-resources/articles/java/javareflection.html
Note: Protecting a constructor prevents the users from creating the instance of the class, outside the package.
https://docs.oracle.com/javase/tutorial/reflect/index.html

https://stackoverflow.com/questions/37628/what-is-reflection-and-why-is-it-useful

One very common use case in Java is the usage with annotations. JUnit 4, for example, will use reflection to look through your classes for methods tagged with the @Test annotation, and will then call them when running the unit test. (Maybe, using getDeclaredAnnotations() of Class class)

Drawbacks of Reflection

Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.

1. Performance Overhead
Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations cannot be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts and should be avoided in sections of code which are called frequently in performance-sensitive applications.

2. Security Restrictions
Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.

3. Exposure of Internals
Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.
-----------------------------------------------------------------------------------------------------------------

Varargs:

public class TestVarargs {

	public static void varargsMeth(String s1,String... args) {
		System.out.println("Single parameter: "+s1);
		System.out.println("Varargs params: ");
		
		for(String v:args)
			System.out.println(v);
	}
	
	public static void main(String[] args) {
		TestVarargs.varargsMeth("simple", "var1","var2","var3");

	}

}


Output:
Single parameter: simple
Varargs params: 
var1
var2
var3



public class TestVarargs {

	public static void varargsMeth(String... args,String s1) {			//Compile time error - "The variable argument type String of the method varargsMeth must be the last parameter"
		System.out.println("Single parameter: "+s1);
		System.out.println("Varargs params: ");
		
		for(String v:args)
			System.out.println(v);
	}
	
	public static void main(String[] args) {
		//TestVarargs.varargsMeth("simple", "var1","var2","var3");

	}

}

-----------------------------------------------------------------------------------------------------------------
Exception:

In order to create a custom exception, we need to extend either Exception or RunTimeException. We extend RuntimeException when we want to create an unchecked exception. If we extend Exception, then it becomes checked exception. (Write a program to verify the same)

-----------------------------------------------------------------------------------------------------------------

Autoboxing/Unboxing:
https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html

Difference between "new Integer()" and "Integer.valueOf()":
https://stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123#:~:text=new%20Integer(123)%20will%20create,call%20it%20more%20than%20once.

-----------------------------------------------------------------------------------------------------------------

New Features in Java 1.5:

1. Generics
2. For/in loop
3. Autoboxing/Unboxing
4. Typesafe Enums
5. Varargs
6. Static Import
7. Annotations (Metadata)
8. ConcurrentHashMap, CopyOnWriteArrayList, CountDownLatch, ReentrantLock  (in java.util.concurrent package)

New Features in Java 1.7:

1. Binary Literals
2. Strings in switch Statement
3. Try with Resources or ARM (Automatic Resource Management)
4. Multiple Exception Handling
5. Suppressed Exceptions
6. underscore in literals
7. Type Inference for Generic Instance Creation using Diamond Syntax


https://stackoverflow.com/questions/213958/new-features-in-java-7

New Features in Java 1.8:

1. Lambda expression âˆ’ Adds functional processing capability to Java.
2. Method references âˆ’ Referencing functions by their names instead of invoking them directly. Using functions as parameter.
3. Default method âˆ’ Interface to have default method implementation.
4. New tools âˆ’ New compiler tools and utilities are added like â€˜jdepsâ€™ to figure out dependencies.
5. Stream API âˆ’ New stream API to facilitate pipeline processing.
6. Date Time API âˆ’ Improved date time API.
7. Optional âˆ’ Emphasis on best practices to handle null values properly.
8. Nashorn, JavaScript Engine âˆ’ A Java-based engine to execute JavaScript code.

------------------------------------------------------------------------------------------------

Can we override static method in java?

https://www.javatpoint.com/can-we-override-static-method-in-java#:~:text=Can%20we%20override%20a%20static,we%20cannot%20override%20static%20methods.
https://docs.oracle.com/javase/tutorial/java/IandI/override.html - important
Static methods in interfaces are never inherited.
The access specifier for an overriding method can allow more, but not less, access than the overridden method.
For example, a protected instance method in the superclass can be made public, but not private, in the subclass.
In a subclass, you can overload the methods inherited from the superclass.
Such overloaded methods neither hide nor override the superclass instance methodsâ€”they are new methods, unique to the subclass.
https://docs.oracle.com/javase/tutorial/java/IandI/super.html
Note: If a constructor does not explicitly invoke a superclass constructor, the Java compiler automatically inserts a call to the no-argument constructor of the superclass. If the super class does not have a no-argument constructor, you will get a compile-time error.
https://docs.oracle.com/javase/tutorial/java/IandI/nogrow.html

------------------------------------------------------------------------------------------------
What You Can Do in a Subclass:

A subclass inherits all of the public and protected members of its parent, no matter what package the subclass is in. If the subclass is in the same package as its parent, it also inherits the package-private members of the parent. You can use the inherited members as is, replace them, hide them, or supplement them with new members:

1. The inherited fields can be used directly, just like any other fields.
2. You can declare a field in the subclass with the same name as the one in the superclass, thus hiding it (not recommended).
3. You can declare new fields in the subclass that are not in the superclass.
4. The inherited methods can be used directly as they are.
5. You can write a new instance method in the subclass that has the same signature as the one in the superclass, thus overriding it.
6. You can write a new static method in the subclass that has the same signature as the one in the superclass, thus hiding it.
7. You can declare new methods in the subclass that are not in the superclass.
8. You can write a subclass constructor that invokes the constructor of the superclass, either implicitly or by using the keyword super.
9. A subclass inherits all the members (fields, methods, and nested classes) from its superclass. Constructors are not members, so they are not inherited by subclasses, but the constructor of the superclass can be invoked from the subclass.

https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

------------------------------------------------------------------------------------------------
Difference between JDK, JRE and JVM
https://www.guru99.com/difference-between-jdk-jre-jvm.html
https://www.geeksforgeeks.org/differences-jdk-jre-jvm/

------------------------------------------------------------------------------------------------
Difference between compiler and interpreter
https://www.guru99.com/difference-compiler-vs-interpreter.html
Compiled code run faster. Interpreted code run slower.
https://www.interviewbit.com/blog/difference-between-compiler-and-interpreter/ (Has good comparison of interpreter and compilers)
https://www.javatpoint.com/is-java-interpreted-or-compiled
1. Write Java code and save the file with .java
2. Now, this file will be compiled using the Java compiler, which is javac.
3. The Java Compiler will compile the Java file and create a .class file having byte code ( which is not actually a machine code, unlike the C compiler)
4. This generated byte code is a non-executable code, and now it needs an interpreter to convert it into machine code. Here the JVM handles it.
5. Now, JVM will execute this byte code to execute Java byte code on a machine.
6. Now, our program will perform the functionality and gives the desired output.
https://www.baeldung.com/java-compiled-interpreted
It is the JVM that is built and customized for each platform that supports Java, rather than our programs or libraries.
------------------------------------------------------------------------------------------------
JIT Compiler
https://stackoverflow.com/questions/95635/what-does-a-just-in-time-jit-compiler-do
289

In the beginning, a compiler was responsible for turning a high-level language (defined as higher level than assembler) into object code (machine instructions), which would then be linked (by a linker) into an executable.

At one point in the evolution of languages, compilers would compile a high-level language into pseudo-code, which would then be interpreted (by an interpreter) to run your program. This eliminated the object code and executables, and allowed these languages to be portable to multiple operating systems and hardware platforms. Pascal (which compiled to P-Code) was one of the first; Java and C# are more recent examples. Eventually the term P-Code was replaced with bytecode, since most of the pseudo-operations are a byte long.
Note: Basically bytecode is nothing but pseudocode which is interpreted by platform dependent JVM.

A Just-In-Time (JIT) compiler is a feature of the run-time interpreter, that instead of interpreting bytecode every time a method is invoked, will compile the bytecode into the machine code instructions of the running machine, and then invoke this object code instead. Ideally the efficiency of running object code will overcome the inefficiency of recompiling the program every time it runs.
------------------------------------------------------------------------------------------------
Can a constructor be made final?

No, a constructor canâ€™t be made final.

A final method cannot be overridden by any subclasses. As mentioned previously, the final modifier prevents a method from being modified in a subclass.

The main intention of making a method final would be that the content of the method should not be changed by any outsider.

But, in inheritance sub class inherits the members of a super class except constructors.

In other words, constructors cannot be inherited in Java therefore, there is no need to write final before constructors. Therefore, java does not allow final keyword before a constructor. If you try a compile time error is generated

------------------------------------------------------------------------------------------------

public class Test {
    String j;

    static public void main(String[] args) {
        String i;
        System.out.println("Testing i: "+i);  //This will give a compile time error, as "i" is not initialized, and it is declared in static block.
        
    }

    void dis(){
        System.out.println(j); // This will compile fine, since the default contructor will assign the default value of null to the variable "j"
    }
}

------------------------------------------------------------------------------------------------
 
Restrictions for the static method
There are two main restrictions for the static method. They are:

1. The static method can not use non static data member or call non-static method directly.
2. this and super cannot be used in static context.

------------------------------------------------------------------------------------------------
Why java main method is static?

Java main() method is always static, so that compiler can call it without the creation of an object or before the creation of an object of the class.

1. In any Java program, the main() method is the starting point from where compiler starts program execution. So, the compiler needs to call the main() method.
2. If the main() is allowed to be non-static, then while calling the main() method JVM has to instantiate its class.
3. While instantiating it has to call the constructor of that class, There will be ambiguity if the constructor of that class takes an argument.
4. Static method of a class can be called by using the class name only without creating an object of a class.
5. The main() method in Java must be declared public, static and void. If any of these are missing, the Java program will compile but a runtime error will be thrown.

------------------------------------------------------------------------------------------------
Can we execute a program without main() method?
Ans) No, one of the ways was the static block, but it was possible till JDK 1.6. Since JDK 1.7, it is not possible to execute a Java class without the

------------------------------------------------------------------------------------------------

Main method concepts:
https://www.javatpoint.com/java-main-method

------------------------------------------------------------------------------------------------

48) Can we make constructors static?
As we know that the static context (method, block, or variable) belongs to the class, not the object. Since Constructors are invoked only when the object is created, there is no sense to make the constructors static. However, if you try to do so, the compiler will show the compiler error.
------------------------------------------------------------------------------------------------

50) Can we declare the static variables and methods in an abstract class?
Yes, we can declare static variables and methods in an abstract method. As we know that there is no requirement to make the object to access the static context, therefore, we can access the static context declared inside the abstract class by using the name of the abstract class.

public class AbstractStaticTest {
    public static void main(String[] args) {
        abst.test();
    }
}


abstract class abst{
    static void test(){
        System.out.println("inside abstract static method");
    }
}

Ouput: inside abstract static method
------------------------------------------------------------------------------------------------

Real usage of this() constructor call:

The this() constructor call should be used to reuse the constructor from the constructor. It maintains the chain between the constructors i.e. it is used for constructor chaining. Let's see the example given below that displays the actual use of this keyword.
See: https://www.javatpoint.com/this-keyword

Call to this() must be the first statement in constructor.

------------------------------------------------------------------------------------------------

54) Can this keyword be used to refer static members?
Yes, It is possible to use this keyword to refer static members because this is just a reference variable which refers to the current class object. However, as we know that, it is unnecessary to access static variables through objects, therefore, it is not the best practice to use this to refer static members.

SEE: https://www.javatpoint.com/this-keyword

------------------------------------------------------------------------------------------------

56) What are the advantages of passing this into a method instead of the current class object itself?
As we know, that this refers to the current class object, therefore, it must be similar to the current class object. However, there can be two main advantages of passing this into a method instead of the current class object.

this is a final variable. Therefore, this cannot be assigned to any new value whereas the current class object might not be final and can be changed.
this can be used in the synchronized block.

------------------------------------------------------------------------------------------------
In java, method overloading is not possible by changing the return type of the method only because of ambiguity. Let's see how ambiguity may occur:

class Adder{  
	static int add(int a,int b){return a+b;}  
	static double add(int a,int b){return a+b;}  
}  
class TestOverloading3{  
	public static void main(String[] args){  
	System.out.println(Adder.add(11,11));//ambiguity  
}}  

------------------------------------------------------------------------------------------------
Example of Method Overloading with TypePromotion

class OverloadingCalculation1{  
  void sum(int a,long b){System.out.println(a+b);}  
  void sum(int a,int b,int c){System.out.println(a+b+c);}  
  
  public static void main(String args[]){  
  OverloadingCalculation1 obj=new OverloadingCalculation1();  
  obj.sum(20,20);//now second int literal will be promoted to long, no compile time error
  obj.sum(20,20,20);  
  
  }  
}
------------------------------------------------------------------------------------------------
Ambiguity:--

public class OverloadingTest {
    void sum(int a,long b){System.out.println("first"+(a+b));}
    void sum(int a,int b,int c){System.out.println("second"+(a+b+c));}
    void sum(long a,int b){System.out.println("third"+(a+b));}

    public static void main(String args[]){
        OverloadingTest obj=new OverloadingTest();
        obj.sum(20,20);//complie time error at this line, due to ambiguity
        obj.sum(20,20,20);

    }
}
------------------------------------------------------------------------------------------------
Ambiguity:--

public class OverloadingTest2 {
    void sum(int a,int b){System.out.println("first"+(a+b));}
    void sum(int a,int b,int c){System.out.println("second"+(a+b+c));}


    public static void main(String args[]){
        OverloadingTest2 obj=new OverloadingTest2();
        obj.sum(20,20.23);//complie time error at this line, since float cant be promoted to int
        obj.sum(20,20,20);

    }
}

------------------------------------------------------------------------------------------------
If there are matching type arguments in the method, type promotion is not performed.

class OverloadingCalculation2{  
  void sum(int a,int b){System.out.println("int arg method invoked");}  
  void sum(long a,long b){System.out.println("long arg method invoked");}  
  
  public static void main(String args[]){  
  OverloadingCalculation2 obj=new OverloadingCalculation2();  
  obj.sum(20,20);//now int arg sum() method gets invoked  
  }  
}
------------------------------------------------------------------------------------------------
SEE: https://www.javatpoint.com/method-overloading-in-java ,for type promotion rule. ALways lower type can be promoted to higher type but not vice-versa.
------------------------------------------------------------------------------------------------
Java Access Modifiers with Method Overriding:

If you are overriding any method, overridden method (i.e. declared in subclass) must not be more restrictive.

class A{  
protected void msg(){System.out.println("Hello java");}  
}  
  
public class Simple extends A{  
void msg(){System.out.println("Hello java");}//C.T.Error  
 public static void main(String args[]){  
   Simple obj=new Simple();  
   obj.msg();  
   }  
}

The default modifier is more restrictive than protected. That is why, there is a compile-time error.

The default methods cannot accessed from outside package,even if it is a sub-package or the class in extended.
------------------------------------------------------------------------------------------------
ExceptionHandling with MethodOverriding in Java:--

There are many rules if we talk about methodoverriding with exception handling. The Rules are as follows:

If SuperClass does not declare an exception, then the SubClass can only declare unchecked exceptions, but not the checked exceptions.
If SuperClass declares an exception, then the SubClass can only declare the same or child exceptions of the exception declared by the SuperClass and any new Runtime Exceptions, just not any new checked exceptions at the same level or higher.
If SuperClass declares an exception, then the SubClass can declare without exception.
------------------------------------------------------------------------------------------------
70) Can you use this() and super() both in a constructor?

No, because this() and super() must be the first statement in the class constructor.
------------------------------------------------------------------------------------------------
Cloning:

https://www.javatpoint.com/object-cloning
https://howtodoinjava.com/java/cloning/a-guide-to-object-cloning-in-java/
No constructor is called on the object being cloned.
"Object.clone() is protected, so we have to provide our own clone() and indirectly call Object.clone() from it."
The question may come into mind that if all classes in java extends Object class and since Object class has the actual implementation of the clone()
method, then why not call the inherited clone() method of the child class(while making a clone), rather than overriding the clone method just to call the Object.clone?
The answer is, since Object.clone is protected, hence it cannot be called from outside generally, hence the clone method is overridden in the child class,
the access scope is changed to public(in child class) and Object.clone is called from there.
------------------------------------------------------------------------------------------------
Covariant Return Type:

The covariant return type specifies that the return type may vary in the same direction as the subclass.

Java 5.0 onwards it is possible to have different return type for a overriding method in child class, but childâ€™s return type should be sub-type of parentâ€™s return type. 

class A{  
	A get(){return this;}  
}  
  
class B1 extends A{  
	B1 get(){return this;}  
	void message(){System.out.println("welcome to covariant return type");}  
  
	public static void main(String args[]){  
		new B1().get().message();  
	}  
}  
------------------------------------------------------------------------------------------------

class Fin2{
    static final int var=10; //since static variables are created while class loading, hence static final variables has to be initialized
                            // at declaration only

    Fin2(int var){
        //this.var=var;  //compile time error, since it is already initialized
    }

    void change(){
        //this.var=10;
    }
}

------------------------------------------------------------------------------------------------
class Fin3{
    static final int var;

    static {
        var=10;    // static variables can also be initialized in static blocks
    }
    
    Fin3(int var){
        //this.var=var;  //compile time error, since it is already initialized
    }

    void change(){
        //this.var=10;
    }
}
------------------------------------------------------------------------------------------------
public class FinalVariableTest4 {
    public static void main(String[] args) {
        final int j;
        j=10;
        System.out.println(j);
    }
    
    void test(){
        final int k;
        k=10;
    }
}

Compiles fine. Method "final" variables can be initialized only once after declaration.
------------------------------------------------------------------------------------------------
Java Runtime Polymorphism with Data Member:

A method is overridden, not the data members, so runtime polymorphism can't be achieved by data members.

In the example given below, both the classes have a data member speedlimit. We are accessing the data member by the reference variable of Parent class which refers to the subclass object. Since we are accessing the data member which is not overridden, hence it will access the data member of the Parent class always.

class Bike{  
 int speedlimit=90;  
}  
class Honda3 extends Bike{  
 int speedlimit=150;  
  
 public static void main(String args[]){  
  Bike obj=new Honda3();  
  System.out.println(obj.speedlimit);//90  
}  
------------------------------------------------------------------------------------------------
Abstract class:

https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html

An abstract class may have static fields and static methods. You can use these static members with a class reference (for example, AbstractClass.staticMethod()) as you would with any other class.

An abstract class can have constructors as well.

A class that is declared as abstract is known as an abstract class. It needs to be extended and its method implemented. It cannot be instantiated. It can have abstract methods, non-abstract methods, constructors, and static methods. It can also have the final methods which will force the subclass not to change the body of the method. Consider the following example.

Methods in an interface, that are not declared as default or static are implicitly abstract, so the abstract modifier is not used with interface methods. (It can be used, but it is unnecessary.)

An example of an abstract class in the JDK is AbstractMap, which is part of the Collections Framework. Its subclasses (which include HashMap, TreeMap, and ConcurrentHashMap) share many methods (including get, put, isEmpty, containsKey, and containsValue) that AbstractMap defines.

Note: Check the section "Abstract Classes Compared to Interfaces" in the above link. It has good comparison.
------------------------------------------------------------------------------------------------
Difference between abstraction and encapsulation:

https://javarevisited.blogspot.com/2017/04/difference-between-abstraction-and-encapsulation-in-java-oop.html

------------------------------------------------------------------------------------------------
SOLID prinicple:
https://www.baeldung.com/solid-principles
https://www.baeldung.com/java-single-responsibility-principle
https://www.baeldung.com/java-open-closed-principle
https://www.baeldung.com/java-liskov-substitution-principle (Has good example of both OCP and Liskov principal. Use this as example.)
The BankingAppWithdrawalService no longer depends on concrete account classes. Because it now depends only on the abstract class, it need not be changed when a new account type is introduced.
Consequently, the BankingAppWithdrawalService is open for the extension with new account types, but closed for modification, in that the new types donâ€™t require it to change in order to integrate.
For the Open/Closed Principle to work well, all subtypes must be substitutable for their supertype without ever having to modify the client code. Adhering to the Liskov Substitution Principle ensures this substitutability.
Basically Liskov substitution helps in achieving open-closed principal.
If the client code needs to use instanceof or downcasting, then the chances are that both the Open/Closed Principle and the Liskov Substitution Principle have been violated.
https://www.baeldung.com/java-liskov-substitution-principle#3-signature-rule---exceptions (Important to understand the overridden method exception declaration rule)

https://www.baeldung.com/java-interface-segregation
One way to refactor a code which does not comply with open-closed principal is by segregating the interfaces into more fine grained interface (Interface segregation).
We can leverage the concept of interface segregation to design our interfaces in such a way that the implementing subtypes can adhere to Liskov's substitution easily. And thus as a whole open-closed principal is achieved.

https://www.baeldung.com/java-dependency-inversion-principle
https://medium.com/@inzuael/solid-dependency-inversion-principle-part-5-f5bec43ab22e

https://stackify.com/solid-design-liskov-substitution-principle/#:~:text=The%20Liskov%20Substitution%20Principle%20in,the%20objects%20of%20your%20superclass. (Liskov substitution)

------------------------------------------------------------------------------------------------
Since java 9, interface can have private methods.
Java 9 introduced java shell REPL tool (jshell).
Java 9 introduced modular system.
https://www.youtube.com/watch?v=5xDoo-PcZ7g&list=PLsyeobzWxl7qjvpYOxlLYYQF4QbQRTwTF (Telusko)
https://www.youtube.com/watch?v=UqnwQp1uHuY (See up until "New Abstraction" segment in the seek bar)
https://www.oracle.com/in/corporate/features/understanding-java-9-modules.html (See "What Is a Module?" and "Goals")
https://www.baeldung.com/java-modularity (Optional read)
https://www.javatpoint.com/java-9-features
https://www.javatpoint.com/java-9-try-with-resources
https://www.javatpoint.com/java-9-anonymous-classes
https://www.javatpoint.com/java-9-factory-methods
Difference between Arrays.asList() and List.of():
Both Arrays.asList() and List.of() returns immutable lists, ie adding and removing new elements throws an UnsupportedOperationException, but individual elements of the list are modifiable.
The main difference from Arrays.asList() is that List.of() returns an immutable list that is a copy of the provided input array. For this reason, changes to the original array arenâ€™t reflected on the returned list. Whereas, Arrays.asList() doesnâ€™t create a copy of the input array, instead it wraps the original array with the List interface. Therefore, changes to the array reflect on the list too.
------------------------------------------------------------------------------------------------
Java 10 new features:
https://www.baeldung.com/java-10-overview
1. List, Map, Set now has copyOf() method which returns unmodifiable copy.
2. java.util.stream.Collectors get additional methods to collect a Stream into unmodifiable List, Map or Set. Example: collect(Collectors.unmodifiableList()).

https://www.baeldung.com/java-10-local-variable-type-inference
This feature is available only for local variables with the initializer.
There is no runtime overhead in using var nor does it make Java a dynamically typed language. The type of the variable is still inferred at compile time and cannot be changed later.
https://www.baeldung.com/java-10-overview#time-based-release-versioning
------------------------------------------------------------------------------------------------
Java 11 new features:
1. A major change in this version is that we donâ€™t need to compile the Java source files with javac explicitly anymore. Instead, we can directly run the file using the java command.
2. Local-Variable Syntax for Lambda Parameters.
3. Not Predicate
4. Collection toArray() method.
5. Http client.
"The new HTTP client from the java.net.http package was introduced in Java 9. It has now become a standard feature in Java 11."

https://howtodoinjava.com/java11/features-enhancements/#4-collection-toarrayintfunction
https://www.baeldung.com/java-11-new-features
------------------------------------------------------------------------------------------------
Marker Interface:

A marker interface is an interface that has no methods or constants inside it. It provides run-time type information about objects, so the compiler and JVM have additional information about the object.

A marker interface is also called a tagging interface.

Java has many built-in marker interfaces, such as Serializable, Cloneable, and Remote.

Let's take the example of the Cloneable interface. If we try to clone an object that doesn't implement this interface, the JVM throws a CloneNotSupportedException. Hence, the Cloneable marker interface is an indicator to the JVM that we can call the Object.clone() method.

In the same way, when calling the ObjectOutputStream.writeObject() method, the JVM checks if the object implements the Serializable marker interface. When it's not the case, a NotSerializableException is thrown. Therefore, the object isn't serialized to the output stream.

------------------------------------------------------------------------------------------------
Exception:

See the exception hierarchy in https://www.javatpoint.com/exception-handling-in-java

140) Is there any case when finally will not be executed?

The finally block will not be executed if program exits(either by calling System.exit() or by causing a fatal error that causes the process to abort).

------------------------------------------------------------------------------------------------
Inner classes:

https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html

Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private.
Inner classes cannot declare any static variables or methods, but can access the static method of the outer class, using syntax like "OuterClass.statMeth()", whereas accessing normal instance methods of the outer class from inner class requires syntax like "OuterClass.this.statMeth()".

------------------------------------------------------------------------------------------------

Why Use Nested Classes?
Compelling reasons for using nested classes include the following:

It is a way of logically grouping classes that are only used in one place: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such "helper classes" makes their package more streamlined.

It increases encapsulation: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared private. By hiding class B within class A, A's members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.

It can lead to more readable and maintainable code: Nesting small classes within top-level classes places the code closer to where it is used.

------------------------------------------------------------------------------------------------
We declare inner classes if a class is necessary for the working of the outer class. 
Like in the Linked List Data Structure, we have a Node inner class.

public class LinkedList{
	class Node{
		int data;
		Node next;
	}

}

https://www.youth4work.com/Talent/Core-Java/Forum/120658-why-did-we-use-inner-classes-in-java-tell-me-the-real-answer
------------------------------------------------------------------------------------------------
Inner classes code example:

public class InnerClassTest {
    public static void main(String[] args) {
        OuterClass out=new OuterClass("Pratik",26);
        OuterClass.InnerClass inn=out.new InnerClass();
        inn.display();
        out.callInner();
    }
}


class OuterClass{
    private String st;
    private int i;

    OuterClass(String st, int i){
        this.st=st;
        this.i=i;
    }

    private void display(){
        System.out.println("st: "+this.st+", i: "+this.i);        
    }
    
    // Calling inner class is possible by creating the instance of the Inner only.
    public void callInner(){
        InnerClass inn2 = new InnerClass();
        inn2.display();
    }

    public static void statTest(){
        System.out.println("Inside outer static method");
    }

    class InnerClass{
        public String st="InnerPrat";

        void display(){
            System.out.println("Inside inner display");
            OuterClass.this.display();
            System.out.println("Inner st: "+this.st+", Outer st: "+OuterClass.this.st);
            OuterClass.statTest();  //Can access static methods of outer class
        }


        //Compile time error
        // Inner classes cannot have static declarations
        /*static void dis(){

        }*/
    }
}


------------------------------------------------------------------------------------------------
Local Inner class:

https://www.javatpoint.com/local-inner-class
https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html
Local inner class cannot be invoked from outside the method.
A local class has access to the members of its enclosing class.
Starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or effectively final.
Starting in Java SE 8, if you declare the local class in a method, it can access the method's parameters.
------------------------------------------------------------------------------------------------

Anonymous Inner classes:

https://www.geeksforgeeks.org/anonymous-inner-class-java/
https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html


public class AnonymousClassTest {
    public static void main(String[] args) {
        OuterClass3 outer = new OuterClass3();
        outer.test();
    }
}

interface AnonymousInter{
    void print();
}

class OuterClass3 {
    String outerString = "Outer String";

    private String test2(){
        return "Instance method";
    }

    public void test(){
        String innerString = "Inner String";
        String shadowTest = "Shadow test";
        // Uncomment this line to see the error.
        // Local variable has to be final or effective final to be accessed from anonymous inner class.
        //innerString = "";
        AnonymousInter ai = new AnonymousInter() {
            String shadowTest = "Inner shadow test";

            @Override
            public void print() {
                // Accessing local(method) and instance variable
                System.out.printf("Inside anonymous implementation: %s %s", innerString, outerString);
                System.out.println();
                // Accessing instance method
                System.out.printf("Accessing instance method from anonymous class: %s", test2());
                System.out.println();
                // We can re-declare the variables inside anonymous class. This will shadow the original variable.
                System.out.printf("Accessing shadow variable: %s", shadowTest);
            }
        };

        ai.print();
    }
}

------------------------------------------------------------------------------------------------

Static Inner Class:

A static class i.e. created inside a class is called static nested class in java. It cannot access non-static data members and methods directly. It can use them only through object reference.
Static Inner class can be accessed by outer class name.

It can access static data members of outer class including private.

------------------------------------------------------------------------------------------------

Static Inner Class example:

public class test {
    public static void main(String[] args) {
        OuterClass out=new OuterClass("Pratik",26);
        OuterClass.InnerClass inn = new OuterClass.InnerClass(); //The way to instantiate a static inner class
        inn.display();
        OuterClass.InnerClass.display2(); //The way to call a static method inside a static inner class
    }
}

class OuterClass{
    private String st;
    private int i;
    private static String stat1="static var";

    OuterClass(String st, int i){
        this.st=st;
        this.i=i;
    }

    private void display(){
        System.out.println("st: "+this.st+", i: "+this.i);
    }

    // Calling inner class is possible by creating the instance of the Inner only.
    public void callInner(){
        InnerClass inn2 = new InnerClass();
        inn2.display();
    }

    public static void statTest(){
        System.out.println("Inside outer static method");
    }

    static class InnerClass{
        public String st="InnerPrat";

        void display(){
            System.out.println("Inside inner display");
            System.out.println(OuterClass.stat1); // Can access static field of outer class
            OuterClass.statTest();  //Can access static methods of outer class
            // Compile time error, as "this" cannot be accessed from a static context
            // System.out.println(OuterClass.this.display());
        }

        static void display2(){
            System.out.println("Inside static method");
        }
    }
}
------------------------------------------------------------------------------------------------

Nested interface:

https://www.javatpoint.com/nested-interface
In the collection framework, the sun microsystem has provided a nested interface Entry. Entry is the subinterface of Map, i.e., accessed by Map.Entry.

------------------------------------------------------------------------------------------------
188) How will you invoke any external process in Java?
By Runtime.getRuntime().exec(?) method. Consider the following example.

public class Runtime1{  
 public static void main(String args[])throws Exception{  
  Runtime.getRuntime().exec("firefox");		//will open firefox browser  
 }  
} 

------------------------------------------------------------------------------------------------
Serialization:

https://www.baeldung.com/java-serialization
https://www.oracle.com/technical-resources/articles/java/serializationapi.html
The class file must be accessible from the system in which the restoration occurs(ie java class file should be present). In other words, the object's class file and methods are not saved; only the object's state is saved.
Serialization does not care about access modifiers such as private -- all nontransient fields are considered part of an object's persistent state and are eligible for persistence.
See: "Customize the Default Protocol" section
Use of custom serialization: Encryption could be added to the output and decryption to the input. They could be used to add extra data to the stream, perhaps a company versioning code. They can be used to stop the serialization of child class whose parent class implements serialization, by throwing the NotSerializableException from overridden writeObject() and readObject() methods.
See: "Caching Objects in the Stream" section

Static fields are not serializable.
See NotSerializableException and InvalidClassException and SerialVersionUID.
https://www.baeldung.com/java-serial-version-uid


------------------------------------------------------------------------------------------------
Externalizable in java
https://www.oracle.com/technical-resources/articles/java/serializationapi.html
See: "Create Your Own Protocol: the Externalizable Interface" section
It is not a marker interface.

The Externalizable interface provides two methods:

public void writeExternal(ObjectOutput out) throws IOException
public void readExternal(ObjectInput in) throws IOException

------------------------------------------------------------------------------------------------
Autoboxing and Unboxing:

It can occur whenever a wrapper class object is expected, and primitive data type is provided or vice versa.

1. Adding primitive types into Collection like ArrayList in Java.
2. Creating an instance of parameterized classes ,e.g., ThreadLocal which expect Type.
3. Java automatically converts primitive to object whenever one is required and another is provided in the method calling.
4. When a primitive type is assigned to an object type.

https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html
------------------------------------------------------------------------------------------------

Anonymous block:
https://www.codesarray.com/view/Anonymous-and-Static-blocks-in-java/
------------------------------------------------------------------------------------------------

Important practice link: https://javaconceptoftheday.com/java-inheritance-practice-coding-questions/
------------------------------------------------------------------------------------------------
Java design patterns:
https://www.journaldev.com/1827/java-design-patterns-example-tutorial

1) CREATIONAL DESIGN PATTERNS:
Factory design pattern:
https://www.journaldev.com/1392/factory-design-pattern-in-java
https://www.geeksforgeeks.org/factory-method-for-designing-pattern/
Example: valueOf() method in wrapper classes like Boolean, Integer etc.

Abstract factory design pattern:
https://www.digitalocean.com/community/tutorials/abstract-factory-design-pattern-in-java

Singleton design pattern:
https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples
Example: java.lang.RunTime.getRuntime

Builder design pattern:
https://www.journaldev.com/1425/builder-design-pattern-in-java
Example: java.lang.StringBuilder#append()

2) STRUCTURAL DESIGN PATTERNS:
Adapter design pattern:
https://www.geeksforgeeks.org/adapter-pattern/
Example: java.util.Arrays#asList()

Composite design pattern:
https://www.geeksforgeeks.org/composite-design-pattern/
https://www.journaldev.com/1535/composite-design-pattern-in-java

Flyweight design pattern:
Flyweight pattern is one of the structural design patterns as this pattern provides ways to decrease object count thus improving application required objects structure.
The flyweight pattern is best suited for immutable objects.
Note: Set of Intrinsic properties determine the unique category of objects we need to store in the cache map.
https://www.geeksforgeeks.org/flyweight-design-pattern/
https://www.journaldev.com/1562/flyweight-design-pattern-java
Example: String pool, valueOf() of wrapper classes in java

Decorator design pattern:
https://www.journaldev.com/1540/decorator-design-pattern-in-java-example
Decorator pattern is used a lot in Java IO classes, such as FileReader, BufferedReader etc.

------------------------------------------------------------------------------------------------
J2EE design patterns:
https://stackabuse.com/java-j2ee-design-patterns/#dataaccessobjectpattern

MVC pattern
DAO pattern
Front Controller pattern (Dispatcherservlet in spring mvc)
Intercepting filter pattern
------------------------------------------------------------------------------------------------

Difference between put, post and patch:
https://www.baeldung.com/cs/http-put-vs-patch
https://www.quora.com/What-is-the-difference-between-PUT-POST-and-PATCH-for-RESTful-APIs

Why patch is non-idempotent:
https://medium.com/@pankaj_rawal/why-patch-is-considered-non-idempotent-1dfd4ca9a2
------------------------------------------------------------------------------------------------
Java memory leak:
https://www.baeldung.com/java-memory-leaks

PermGen vs MetaSpace:
https://www.baeldung.com/java-permgen-metaspace
Starting with Java 8, the Metaspace replaces the PermGen bringing some substantial changes.
Check ChatGPT.
https://chatgpt.com/c/6868bd96-fe4c-8005-9b83-0e9d13b0a6a9 (See archived chats)

Java memory management:
https://www.linkedin.com/learning/java-memory-management-values-and-references/make-beautiful-stack-overflow-errors?dApp=53239054&leis=LAA&resume=false&u=2113185
https://www.baeldung.com/java-memory-management-interview-questions
------------------------------------------------------------------------------------------------
Custom Exception:
https://www.baeldung.com/java-new-custom-exception

-----------------------------------------------------------------------------------------------
Difference between ASCII and Base64 encoding and their utility:
https://www.redhat.com/en/blog/base64-encoding#:~:text=ASCII%20uses%208%20bits%20to,up%20into%206%2Dbit%20chunks.

Why do we need base64 encoding:
https://www.youtube.com/watch?v=MI0W6FdDjTY
-----------------------------------------------------------------------------------------------
When to use static variables:
When we need to share common state across all the instances of a class, say for an employee class if we want to maintain the number of employees created.
-----------------------------------------------------------------------------------------------
Check Date comparison operations.
-----------------------------------------------------------------------------------------------