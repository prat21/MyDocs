https://docs.spring.io/spring-framework/reference/data-access/transaction.html
-------------------------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/data-access/transaction/motivation.html

See what are global and local transactions.
-------------------------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/data-access/transaction/strategies.html

Regardless of whether you opt for declarative or programmatic transaction management in Spring, defining the correct TransactionManager implementation is absolutely essential. You typically define this implementation through dependency injection.
TransactionManager implementations normally require knowledge of the environment in which they work: JDBC, JTA, Hibernate, and so on.
In all Spring transaction setups, application code does not need to change. You can change how transactions are managed merely by changing configuration, even if that change means moving from local to global transactions or vice versa.
--------------------------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/rolling-back.html

In its default configuration, the Spring Framework’s transaction infrastructure code marks a transaction for rollback only in the case of runtime, unchecked exceptions(Error instances also, by default, result in a rollback).
Checked exceptions that are thrown from a transactional method do not result in a rollback in the default configuration. You can configure exactly which Exception types mark a transaction for rollback, including checked exceptions by specifying rollback rules.

--------------------------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html

In addition to the XML-based declarative approach to transaction configuration, you can use an annotation-based approach. Declaring transaction semantics directly in the Java source code puts the declarations much closer to the affected code. There is not much danger of undue coupling, because code that is meant to be used transactionally is almost always deployed that way anyway.

The standard jakarta.transaction.Transactional annotation is also supported as a drop-in replacement to Spring’s own annotation. Please refer to the JTA documentation for more details.

Used at the class level as above, the annotation indicates a default for all methods of the declaring class (as well as its subclasses). Alternatively, each method can be annotated individually. See method visibility for further details on which methods Spring considers transactional. Note that a class-level annotation does not apply to ancestor classes up the class hierarchy; in such a scenario, inherited methods need to be locally redeclared in order to participate in a subclass-level annotation.

The @Transactional annotation is typically used on methods with public visibility. As of 6.0, protected or package-visible methods can also be made transactional for class-based proxies by default. Note that transactional methods in interface-based proxies must always be public and defined in the proxied interface. For both kinds of proxies, only external method calls coming in through the proxy are intercepted.

The Spring team recommends that you annotate methods of concrete classes with the @Transactional annotation, rather than relying on annotated methods in interfaces, even if the latter does work for interface-based and target-class proxies as of 5.0. Since Java annotations are not inherited from interfaces, interface-declared annotations are still not recognized by the weaving infrastructure when using AspectJ mode, so the aspect does not get applied. As a consequence, your transaction annotations may be silently ignored: Your code might appear to "work" until you test a rollback scenario.

In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with @Transactional. Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code — for example, in a @PostConstruct method (Because in spring, beans are wrapped with proxies using bean post processors, and it generally happens after bean initialization using the method postProcessAfterInitialization()).

Consider using AspectJ mode if you expect self-invocations to be wrapped with transactions as well. In this case, there is no proxy in the first place. Instead, the target class is woven (that is, its byte code is modified) to support @Transactional runtime behavior on any kind of method. (Also check the "mode" and "proxyTargetClass" attributes in the table below)

The default advice mode for processing @Transactional annotations is proxy, which allows for interception of calls through the proxy only. Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to aspectj mode in combination with compile-time or load-time weaving.

The proxy-target-class attribute controls what type of transactional proxies are created for classes annotated with the @Transactional annotation. If proxy-target-class is set to true, class-based proxies are created. If proxy-target-class is false or if the attribute is omitted, standard JDK interface-based proxies are created.

The @Transactional annotation is metadata that specifies that an interface, class, or method must have transactional semantics (for example, "start a brand new read-only transaction when this method is invoked, suspending any existing transaction"). The default @Transactional settings are as follows:
1. The propagation setting is PROPAGATION_REQUIRED.
2. The isolation level is ISOLATION_DEFAULT.
3. The transaction is read-write.
4. The transaction timeout defaults to the default timeout of the underlying transaction system or none if timeouts are not supported.
5. Any RuntimeException or Error triggers rollback, and any checked Exception does not.

https://docs.spring.io/spring-framework/reference/data-access/transaction/declarative/annotations.html#tx-multiple-tx-mgrs-with-attransactional

Most Spring applications need only a single transaction manager, but there may be situations where you want multiple independent transaction managers in a single application. You can use the value or transactionManager attribute of the @Transactional annotation to optionally specify the identity of the TransactionManager to be used. This can either be the bean name or the qualifier value of the transaction manager bean.
--------------------------------------------------------------------------------------------------------------
https://www.youtube.com/watch?v=SUQxXg229Xg
https://www.youtube.com/watch?v=95kxPSbHzVg
https://www.baeldung.com/transaction-configuration-with-jpa-and-spring

At a high level, Spring creates proxies for all the classes annotated with @Transactional, either on the class or on any of the methods.
The proxy allows the framework to inject transactional logic before and after the running method, mainly for starting and committing the transaction.
What's important to keep in mind is that, if the transactional bean is implementing an interface, by default the proxy will be a Java Dynamic Proxy.
This means that only external method calls that come in through the proxy will be intercepted.
Any self-invocation calls will not start any transaction, even if the method has the @Transactional annotation.
The @Transactional annotation is typically used on methods with public visibility. As of 6.0, protected or package-visible methods can also be made transactional for class-based proxies by default. Note that transactional methods in interface-based proxies must always be public and defined in the proxied interface. For both kinds of proxies, only external method calls coming in through the proxy are intercepted.
