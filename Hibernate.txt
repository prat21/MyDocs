1. Hibernate gets the value of the property of an object from the getters to save in the database. See: Hibernate Tutorial 04 - hbm2ddl Configuration and Name Annotations (12.09 minute)

2. Some pointers regarding the hbm2ddl.auto property of hibernate xml. See: Hibernate Tutorial 04 - hbm2ddl Configuration and Name Annotations (8.51 minute)

3. What is the difference between @Entity and @Table? https://stackoverflow.com/questions/18732646/name-attribute-in-entity-and-table, See : Hibernate Tutorial 05 - More Annotations (1.06 min)

4. @Transient keyword is used by hibernate when some field of an object does not need to be saved in the database. @Transient is an annotation used by hibernate to denote those fields which are not going to be persisted in the db and "transient" keyword is a java keyword used in case of serialization to denote the fields which are not be serialized. See : Hibernate Tutorial 05 - More Annotations (9.06 min)

5. @Temporal is used to define the date format. For example @Temporal(TemporalType.DATE) like "2017-05-16" or @Temporal(TemporalType.TIMESTAMP) like "2017-05-16 09:50:02.179". SEE : Hibernate Tutorial 05 - More Annotations (9.50 min)

6. @Lob is by hibernate used to save CLOB (Character large objects) or BLOB (Byte Stream large Objects) into database. SEE : Hibernate Tutorial 05 - More Annotations (12.20 min)

7. When we use "session.get(UserDetails.class , arg2)" to retrieve data from db, we use the class name as the argument and not the table name, since when we code in hibernate we visualize objects and not database tables. SEE : Hibernate Tutorial 06 - Retrieving Objects using session.get

8. Difference between natural key and surrogate key. If the primary key of a table is natural key(ie it is unique and has business significance, like email address of an employee), then  we need to explicitly provide the primary key. But if it is a surrogate key (ie it does not have any business significance and is there just to uniquely identify a row) then it can be auto generated by hibernate. @GeneratedValue SEE : Hibernate Tutorial 07 - Primary Keys

9. An entity object is an independent object and can exist on its own. A value object is an object which depends on other object and has no meaningful existence on its own. For example, a "User" object is an entity object, but a "Address" object is a value object beacuse Address is dependent on User and Address cannot exist on its own (A User has an Address). It is same as "composition" concept in OOP. SEE : Hibernate Tutorial 08 - Value Types and Embedding Objects

------------------------------------------------------------------------------------------------------------------------------
When we have a value object inside an entity object:

10. @Embeddable: is used to annotate an object as a value object. Hibernate will not create a seperate table for an @Embeddable object. A value object is marked as @Embedded inside an minity object. SEE : Hibernate Tutorial 08 - Value Types and Embedding Objects (8.10 min)


11. @ElementCollection: is used to store a collection of objects into a seperate table. The list or set of objects (say list of addresses) is stored in a seperate table with the primary key of the entity class as foreign key. SEE : Hibernate Tutorial 10 - Saving Collections.

12. @JoinTable: is used in conjuction with @ElementCollection to specify the name, joincolumn name (using @JoinColumn annotation) of the seperate table of value objects. SEE : Hibernate Tutorial 11 - Configuring Collections and Adding Keys

13. @CollectionId: is used to specify the primary key name,generation logic etc. of that seperate table of value objects.
	@GenericGenerator: is used to define the primary key generator of the @CollectionId. These all are hibernate specific annotations and not JPA annotation.
	SEE : Hibernate Tutorial 11 - Configuring Collections and Adding Keys


14. Proxy class, Lazy and Eager Intialization : @ElementCollection(fetch=FetchType.EAGER) very important. Watch - Hibernate Tutorial 12 - Proxy Objects and Eager and Lazy Fetch Types


------------------------------------------------------------------------------------------------------------------------------
When we have an entity object inside an entity object (OneToOne):
Let us assume that a user can have only one vehicle.

15. @OneToOne: is used to map two entity objects who are in a one-to-one relationship, say a "User" object can have only one "Vehicle" object. In that case we can map the user object to the vehicle object by having a vehicle entity inside user class.

@Entity
@Table(name="USER_DETAILS")
Class User{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int userId;
	private String userName;
	
	@OneToOne
	private Vehicle vehicle;
}


@Entity
Class Vehicle{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int vehicleId;
	private String vehicleName;
}


In this case there will be a foreign key inside the "USER_DETAILS" table which points to the "Vehicle" table like : INSERT INTO USER_DETAILS (userId,userName,vehicle_vehicleId).
We can change the join column name by using the annotation @JoinColumn, just as explained above.


@Entity
@Table(name="USER_DETAILS")
Class User{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int userId;
	private String userName;
	
	@OneToOne
	@JoinColumn(name="VEHICLE_ID")
	private Vehicle vehicle;
}

In this case, the insert statement will be: INSERT INTO USER_DETAILS (userId,userName,VEHICLE_ID).
SEE: Hibernate Tutorial 13 - One To One Mapping



------------------------------------------------------------------------------------------------------------------------------
When we have an entity object inside an entity object (OneToMany):
Let us assume that a user can have multiple vehicles.

16. @OneToMany: is used to map two entities with one-to-many relationship.


@Entity
@Table(name="USER_DETAILS")
Class User{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int userId;
	private String userName;
	
	@OneToMany
	private List<Vehicle> vehicle = new ArrayList<Vehicle>();
}


@Entity
Class Vehicle{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int vehicleId;
	private String vehicleName;
}


This will generate tables like this:

INSERT INTO USER_DETAILS (userId,userName).
INSERT INTO Vehicle (vehicleId,vehicleName).
INSERT INTO USER_DETAILS_Vehicle (USER_DETAILS_userId , Vehicle_vehicleId).


To change the default names of the join table, we can use the annotations @JoinTable and @JoinColumn.

@Entity
@Table(name="USER_DETAILS")
Class User{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int userId;
	private String userName;
	
	@OneToMany
	@JoinTable(name="USER_VEHICLE" , joinColumns=@JoinColumn(name="USER_ID"), inverseJoinColumns=@JoinColumn(name="VEHICLE_ID"))
	private List<Vehicle> vehicle = new ArrayList<Vehicle>();
}

"inverseJoinColumns" is used to define the name of the join column on the other table.

This will generate tables like this:

INSERT INTO USER_DETAILS (userId,userName).
INSERT INTO Vehicle (vehicleId,vehicleName).
INSERT INTO USER_VEHICLE (USER_ID , VEHICLE_ID).

We can also do the mapping from vehicle to user,ie a many-to-one relationship. So, that given a vehicle, we can fetch the corresponnding user.


@Entity
Class Vehicle{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int vehicleId;
	private String vehicleName;
	
	@ManyToOne
	private User user;
}

So, that when we call vehicle.getUser(), the proxy class will query the database (lazy intialization) to fetch the user of that vehicle. If there were no @ManyToOne mapping in vehicle class, then there was no way to get the user of given vehicle.


mappedBy attribute: Another thing we can do is that instead of having a seperate table to map User and Vehicle, we can put the mapping in the Vehicle table itself. This can be done by using mappedBy attribute of @OneToMany. See below:


@Entity
@Table(name="USER_DETAILS")
Class User{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int userId;
	private String userName;
	
	@OneToMany(mappedBy="user")									//"user" is the bean property on the other class(private User user), ie Vehicle, which defines the mapping
	private List<Vehicle> vehicle = new ArrayList<Vehicle>();
}


@Entity
Class Vehicle{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int vehicleId;
	private String vehicleName;
	
	@ManyToOne
	@JoinColumn(name="USER_ID")									//Name of the join column in the Vehicle table
	private User user;
}

mappedBy explained: https://stackoverflow.com/questions/9108224/can-someone-please-explain-mappedby-in-hibernate

SEE: Hibernate Tutorial 14 - One To Many Mapping


------------------------------------------------------------------------------------------------------------------------------

When we have an entity object inside an entity object (ManyToMany):
Let us assume that a user can have multiple vehicles and a vehicle can have multiple users.

17. @ManyToMany: is used to map two entities having many-to-many relationship. Let us see:


@Entity
@Table(name="USER_DETAILS")
Class User{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int userId;
	private String userName;
	
	@ManyToMany
	private List<Vehicle> vehicle = new ArrayList<Vehicle>();
}


@Entity
Class Vehicle{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int vehicleId;
	private String vehicleName;
	
	@ManyToMany
	private List<User> users = new ArrayList<User>();			//A list since a vehicle can have multiple users.
}

If we run this, the generated tables will be something like this:

INSERT INTO USER_DETAILS (userId,userName).
INSERT INTO Vehicle (vehicleId,vehicleName).
INSERT INTO Vehicle (vehicleId,vehicleName).				//Suppose we are inserting two vehicles
INSERT INTO USER_DETAILS_Vehicle (USER_DETAILS_userId , Vehicle_vehicleId).
INSERT INTO USER_DETAILS_Vehicle (USER_DETAILS_userId , Vehicle_vehicleId).
INSERT INTO Vehicle_USER_DETAILS (Vehicle_vehicleId , USER_DETAILS_userId).
INSERT INTO Vehicle_USER_DETAILS (Vehicle_vehicleId , USER_DETAILS_userId).

There are two tables USER_DETAILS_Vehicle and Vehicle_USER_DETAILS to maintain the mappings. That is because we hibernate sees two @ManyToMany annotations and creates a mapping for each of them. So, in order to tell hibernate to create only one mapping and ignore the other one we use the "mappedBy" attribute as explained above.
The modified code is given below.


@Entity
@Table(name="USER_DETAILS")
Class User{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int userId;
	private String userName;
	
	@ManyToMany
	private List<Vehicle> vehicle = new ArrayList<Vehicle>();
}


@Entity
Class Vehicle{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int vehicleId;
	private String vehicleName;
	
	@ManyToMany(mappedBy="vehicle")							//This tells hibernate that the mapping is maintained by the "vehicle" property of the other class, ie User class
	private List<User> users = new ArrayList<User>();
}


After this the queries generated will be like:

INSERT INTO USER_DETAILS (userId,userName).
INSERT INTO Vehicle (vehicleId,vehicleName).
INSERT INTO Vehicle (vehicleId,vehicleName).
INSERT INTO USER_DETAILS_Vehicle (USER_DETAILS_userId , Vehicle_vehicleId).
INSERT INTO USER_DETAILS_Vehicle (USER_DETAILS_userId , Vehicle_vehicleId).

Again as before, we can change the name of the mapping table as well as the column names, using the @JoinTable and @JoinColumn annotations (with joinColumns and inverseJoinColumns attributes), in the User class since that is the class responsible for the mapping.

SEE: Hibernate Tutorial 15 - Many To Many Mapping

------------------------------------------------------------------------------------------------------------------------------

18. Cascade: is an sttribute of @OneToMany. Previously we used to save the entity objects like this:

User user = new User();
user.setUserName("First User);

Vehicle vehicle1 = new Vehicle();
vehicle1.setVehicleName("Car");

Vehicle vehicle2 = new Vehicle();
vehicle2.setVehicleName("Car");

user.getVehicle().add(vehicle1);
user.getVehicle().add(vehicle2);
....Initialize sessionFactory........
session.save(User);
session.save(Vehicle1);
session.save(Vehicle2);

That is we had to save the vehicle objects seperately. Since vehicle are entities, hence it can exist independently. If it were a value object, like "Address"(explained previously), then it would have to be associated with a User object and it would have no existence without a User object. So, in that case saving a user object would have saved the Address object as well, we dont need to save Address object seperately.

But Since Vehicle are entity themselves, hence it is an independent obejct and saving the User object is not enough to save the Vehicle objects, hibernate cannot make the decision to save the Vehicle objects when a User object is saved. So, in order to tell hibernate to save the Vehicle object while saving the User object, we use Cascade.

@Entity
@Table(name="USER_DETAILS")
Class User{
	@Id @GeneratedValue(Strategy=GenerationType.AUTO)
	private int userId;
	private String userName;
	
	@OneToMany(cascade=CascadeType.PERSIST)
	private List<Vehicle> vehicle = new ArrayList<Vehicle>();
}

Hence when we persist a User object,all the vehicles in the list of vehicles are saved as well. In this case we have to use

session.persist(User);

instead of session.save(User). The difference between save and persist will be explained later.

CascadeType.ALL cascades the effect of all operations like save, get, delete etc.

SEE: Hibernate Tutorial 16 - CascadeTypes and Other Things

------------------------------------------------------------------------------------------------------------------------------

19. @Inheritance(strategy=InheritanceType.SINGLE_TABLE): is used to define what type of strategy is to be used to save objects that inherit from the same parent, in database. One strategy is SINGLE_TABLE. This strategy saves all the objects inherited from a parent (including the parent itself into a single table). The syntax is:

@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name="VEHICLE_TYPE" , discriminatorType=DiscriminatorType.STRING)
class Vehicle{
	................
}

@Entity
@DiscriminatorValue("Bike")
class TwoWheeler extends Vehicle{
	..............
}

Discriminator is used in the single table to determine the class of the object.By @DiscriminatorColumn we can change the name of the discriminator column and datatype.
@DiscriminatorValue is used to change the default value of the discriminator column of a particular class. The default value of the discriminator column of a particular class is the name of the class itself.

SEE: Hibernate Tutorial 17 & 18 - Implementing Inheritance - Single Table Strategy

------------------------------------------------------------------------------------------------------------------------------

20. @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS): In this strategy, a seperate table is used to for each of the child class and parent class. So, in this case there is no need for discriminator column and the tables are in normalized form, ie there is no redundant columns. Here the annotations @DiscriminatorColumn and @DiscriminatorValue is not required.

@Entity
@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)
class Vehicle{
	................
}
SEE: Hibernate Tutorial 19 - Implementing Inheritance With Table Per Class Strategy
------------------------------------------------------------------------------------------------------------------------------

20. @Inheritance(strategy=InheritanceType.JOINED): In this strategy, there is a parent table that contains all the attributes of the parent class as columns, ie it contains the common properties of all the child classes. And for each of the child class there is a corresponding table that contains the columns that are specific to that class. Also in the child table, there is foreign key to join with the parent table to retrieve the common properties.

@Entity
@Inheritance(strategy=InheritanceType.JOINED)
class Vehicle{
	................
}
SEE: Hibernate Tutorial 20 - Implementing Inheritance With Joined Strategy

------------------------------------------------------------------------------------------------------------------------------
21. CRUD operations: Create operation can be done using session.save() and Read can be done using session.get().

In order to delete a record, first we have to fetch that record from the database and then call delete method.

User user = (User)session.get(User.class , 2);
session.delete(user);
session.getTransaction().commit();
session.close();

In order to update a record, first we fetch the record, update a property using a setter and then call update method.

User user = (User)session.get(User.class , 2);
user.setUserName("Updated User");
session.update(user);
session.getTransaction().commit();
session.close();

------------------------------------------------------------------------------------------------------------------------------

22. Transient, Persistent and Detached Objects: Very Important. SEE: (Hibernate Tutorial 22 - Transient, Persistent and Detached Objects) AND (Hibernate Tutorial 23 - Understanding State Changes) AND (Hibernate Tutorial 24 - Persisting Detached Objects)


------------------------------------------------------------------------------------------------------------------------------

23. HQL: In hibernate query language, we use objects instead of tables. We use Query objects in HQL. Example:
Here we use org.hibernate.query instead of javax.persistence.query

Query query = session.createQuery("from User where userId>5");
List<User> users = (List<User>)query.list();

SEE: Hibernate Tutorial 25 - Introducing HQL and the Query Object

------------------------------------------------------------------------------------------------------------------------------

24. HQL: We can select a particular column instead of all the columns:

Query query = session.createQuery("select userName from User");
List<String> users = (List<String>)query.list();				//Since here we are returning a single string, hence we use List<String> instead of List<User>

If we add multiple columns in the select clause, then list() method will return List<List<String>>.

We can implement pagination in HQL by:

Query query = session.createQuery("from User");
query.setFirstResult(5);						//Offset 5
query.setMaxResults(4);							//Limit 4
List<User> users = (List<User>)query.list();


It is going to return rows starting from 5th row upto maximum of 4 rows.

SEE: Hibernate Tutorial 26 - Select and Pagination in HQL

------------------------------------------------------------------------------------------------------------------------------

25. Parameters and NamedParameters: We can use parameters in HQL:


Query query = session.createQuery("select userName from User where userId > ? and userName = ?");
query.setInteger(0,5);
query.setString(1,"Second User");
List<String> users = (List<String>)query.list();

We can use NamedParameters as well:

Query query = session.createQuery("select userName from User where userId > :userId and userName = :userName");
query.setInteger("userId",5);
query.setString("userName","Second User");
List<String> users = (List<String>)query.list();



------------------------------------------------------------------------------------------------------------------------------

26. Second Level Cache and @Cacheable and @Cache annotations: SEE: (Hibernate Tutorial 32 - Cacheing in Hibernate) AND (Hibernate Tutorial 33 - Configuring Second Level Cache) AND (Hibernate Tutorial 34 - Using Query Cache)


------------------------------------------------------------------------------------------------------------------------------

27. @NamedQuery and @NamedNativeQuery: SEE: Hibernate Tutorial 28 - Named Queries

------------------------------------------------------------------------------------------------------------------------------

SEE: Hibernate with Spring (spring tutorial 45) and spring java configuration (including propertyplaceholderconfigurer and all annotations)

https://www.baeldung.com/hibernate-5-spring
https://www.baeldung.com/the-persistence-layer-with-spring-and-jpa

Advantage of using spring data jpa(alongwith hibernate as a jpa provider) over spring+hibernate:
https://stackoverflow.com/questions/23862994/what-is-the-difference-between-hibernate-and-spring-data-jpa
https://dzone.com/articles/what-is-the-difference-between-hibernate-and-sprin-1
Let's say you are using spring + hibernate for your application. Now you need to have dao interface and implementation where you will be writing crud operation using SessionFactory of hibernate. Let say you are writing dao class for Employee class, tomorrow in your application you might need to write similiar crud operation for any other entity. So there is lot of boilerplate code we can see here.
Now Spring data jpa allow us to define dao interfaces by extending its repositories(crudrepository, jparepository) so it provide you dao implementation at runtime. You don't need to write dao implementation anymore.Thats how spring data jpa makes your life easy.
So, basically spring jpa is another layer of abstraction on top of hibernate to avoid boilerplate code.

Difference between sessionFactory and entityManagerFactory:
https://stackoverflow.com/questions/5640778/hibernate-sessionfactory-vs-jpa-entitymanagerfactory
Prefer EntityManagerFactory and EntityManager. They are defined by the JPA standard.
SessionFactory and Session are hibernate-specific. The EntityManager invokes the hibernate session under the hood.

EntityScan vs LocalContainerEntityManagerFactoryBean#setPackagesToScan:
Configures the LocalContainerEntityManagerFactoryBean to to scan for entity classes in the classpath.
This annotation provides an alternative to manually setting LocalContainerEntityManagerFactoryBean#setPackagesToScan(String...) and is particularly useful if you want to configure entity scanning in a type-safe way, or if your LocalContainerEntityManagerFactoryBean is auto-configured.
Furthermore, any existing packagesToScan setting will be replaced.

--------------------------------------------------------------------------------------------------
https://javarevisited.blogspot.com/2013/05/10-hibernate-interview-questions-answers-java-j2ee-senior.html


















