SEE:https://docs.spring.io/spring-boot/docs/1.1.x/reference/htmlsingle/#getting-started-first-application and java brains

----------------------------------------------------------------------------------------------------------------------------------------

The ideal way to setup spring boot application is to create a maven project and add the spring boot dependency into it. For example when we create the spring mvc using spring boot, we add the spring-boot-starter-web dependency. When maven encounters this dependency, it downloads all the jars related to that dependency and adds them to classpath. In this case maven downloads all the jars related to spring mvc (like spring-web and spring-web-mvc etc.) and add them to classpath.

When SpringApplication.run() runs, it scans the classpath and according to the jars present in the classpath, it takes necessary configuration steps. For example in this case, when springboot encounters the spring mvc jars in the classpath, it intializes a DsiaptcherServlet and takes other steps necessary for bootstrapping spring mvc project.

----------------------------------------------------------------------------------------------------------------------------------------
@SpringBootApplication is a convenience annotation that adds all of the following:

1. @Configuration tags the class as a source of bean definitions for the application context.

2. @EnableAutoConfiguration tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings.

3. Normally you would add @EnableWebMvc for a Spring MVC app, but Spring Boot adds it automatically when it sees spring-webmvc on the classpath. This flags the application as a web application and activates key behaviors such as setting up a DispatcherServlet.

4. @ComponentScan tells Spring to look for other components, configurations, and services in the hello package (in the package that where the main() class resides and its sub-packges), allowing it to find the controllers.

SEE: https://spring.io/guides/gs/spring-boot/

----------------------------------------------------------------------------------------------------------------------------------------
Spring Boot:

"Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run"."

1. Opinionated 
(it gives an opinion about a project, as in what should be the starting point of your project or what should be the intial structure of the project and creates that project and configurations for you. Having the default project with you, you are then free to make custom configrations in it.)

2. Convention over Configuration
(It configures a project using the default configuration assuming that the developer may want to use the default configs, ie it uses standard convention to setup a project and do the majority of the default work for the developer. If the developer wants to do some custom config, he is welcome to do so.)
https://www.techopedia.com/definition/27478/convention-over-configuration
https://facilethings.com/blog/en/convention-over-configuration

3. Stand alone 
(It does not a servlet container. It embeds a container of its own and while bootstraping the application using spring application context, it intializes the container and starts it. Hence it is stand alone.)

4. Production ready 
(ie, we do not have to configure anything extra,just package the application as jar and run it in production. No extra config needed.)

5. AutoConfiguration:
It auto configures many aspects of the application(using @EnableAutoConfiguration). Like if you have some database jar in your classpath, then it auto configures a dataSource for you. You can always override the default configs using "exclude" attribute of @EnableAutoConfiguration.

@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}

you can also control the list of auto-configuration classes to exclude by using the spring.autoconfigure.exclude property.
SEE:https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html
https://stackoverflow.com/questions/35005158/what-is-the-difference-between-componentscan-and-enableautoconfiguration-in-sp


SEE: Spring Boot Quick Start 5 - What Spring Boot gives us
----------------------------------------------------------------------------------------------------------------------------------------
Starting Spring Boot:

What does the class SpringApplication.run(); does behind the scenes:

1. Sets up default configuration (convention over configuration)
2. Starts Spring Application Context (Starts the Application context, ie the Spring container which handles all the beans)
3. Performs class path scan (It scans the class path for all the classes that are annotated with @Controller, @Service and so on)
4. Starts Tomcat Server

SEE: Spring Boot Quick Start 10 - Spring Boot startup steps (Java Brains)

----------------------------------------------------------------------------------------------------------------------------------------
From: https://docs.spring.io/spring-boot/docs/1.1.x/reference/htmlsingle/#getting-started-first-application

10.3.3 The “main” method

The final part of our application is the main method. This is just a standard method that follows the Java convention for an application entry point. Our main method delegates to Spring Boot’s SpringApplication class by calling run. SpringApplication will bootstrap our application, starting Spring which will in turn start the auto-configured Tomcat web server. We need to pass Example.class as an argument to the run method to tell SpringApplication which is the primary Spring component. The args array is also passed through to expose any command-line arguments.

----------------------------------------------------------------------------------------------------------------------------------------

A snippet of log when spring boot starts:
2018-10-02 12:51:37.583  INFO 7204 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Servlet dispatcherServlet mapped to [/]

Note that spring boot automatically registers and maps the DispatcherServlet to the url-mapping "/"(An example of auto configuration, when spring boot sees spring mvc jars in the classpath).

Check the logs once when boot starts.

----------------------------------------------------------------------------------------------------------------------------------------


Check how spring boot does the component scan. Whether we need to put the @Controller annotated classes on the same package hierarchy as the main() class or not.- Checked, the annotated classes has to be in the same package hierarchy as the main() class. This is the default configuration that spring boot configures(convention over configuration).

SEE also: https://spring.io/guides/gs/spring-boot/

@SpringBootApplication implicitly adds the @ComponentScan anntation and it scans all the classes in the package(and sub-packages) where the main() class resides.

----------------------------------------------------------------------------------------------------------------------------------------

Spring Boot: Bills of Materials

Generally when we configure a Spring MVC using Spring Boot, we give the dependencies in the pom.xml like:

	<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.5.RELEASE</version>
    </parent>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>

Instead of giving all the dependencies that is required to build the Spring MVC project without Spring Boot, we provide only:

	<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
    </dependencies>
	
This tells maven which jars to download, and this:

	<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.5.RELEASE</version>
    </parent>


tells maven what versions of those jars to download. The version of the parent(spring-boot-starter-parent) determines, what versions of the jars to download. These versions of the jars are compatible with each other and is known as "Bills of Materials". These preset version of jars are determined by the spring as to be compatible versions.

SEE: Spring Boot Quick Start 13 - What's Happening Here: Bill Of Materials

----------------------------------------------------------------------------------------------------------------------------------------

Embedded Tomcat Server Advantages:

1. Convenience
2. Servlet Container config is now application config (ie Server related config can now be done in code itself)
3. Standalone Application
4. Useful for MicroService Architecture (In microservice architecture, deploying multiple modules in servers multiple times can be cumbersome. Whereas using Spring Boot, deploying a application is as simple as running a command and the application is up and running.)

If we want other server than tomcat, we need to mention that in the pom.xml.

Why Spring Boot for MicroServices?
https://www.quora.com/What-are-microservices-How-is-it-related-with-Spring-Boot-for-Java

SEE: Spring Boot Quick Start 14 - What's Happening Here: Embedded Servlet Container

Also see later:
https://spring.io/blog/2015/07/14/microservices-with-spring

See what docker does,it is interesting.
https://www.3pillarglobal.com/insights/building-a-microservice-architecture-with-spring-boot-and-docker-part-i

----------------------------------------------------------------------------------------------------------------------------------------

From: https://docs.spring.io/spring-boot/docs/1.1.x/reference/htmlsingle/#getting-started-first-application

We generally recommend that you locate your main application class in a root package above other classes. The @EnableAutoConfiguration annotation is often placed on your main class, and it implicitly defines a base “search package” for certain items. For example, if you are writing a JPA application, the package of the @EnableAutoConfiguration annotated class will be used to search for @Entity items.

Using a root package also allows the @ComponentScan annotation to be used without needing to specify a basePackage attribute.

----------------------------------------------------------------------------------------------------------------------------------------

From: https://docs.spring.io/spring-boot/docs/1.1.x/reference/htmlsingle/#getting-started-first-application

10.5 Creating an executable jar:

Let’s finish our example by creating a completely self-contained executable jar file that we could run in production. Executable jars (sometimes called “fat jars”) are archives containing your compiled classes along with all of the jar dependencies that your code needs to run.

To create an executable jar we need to add the spring-boot-maven-plugin to our pom.xml. Insert the following lines just below the dependencies section:

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>

Save your pom.xml and run "mvn package" (or "mvn clean install") from the command line.

If you look in the target directory you should see myproject-0.0.1-SNAPSHOT.jar. The file should be around 10 Mb in size.

You should also see a much smaller file named myproject-0.0.1-SNAPSHOT.jar.original in the target directory. This is the original jar file that Maven created before it was repackaged by Spring Boot.

To run that application, use the java -jar command.

Note: Executable jars and Java

Java does not provide any standard way to load nested jar files (i.e. jar files that are themselves contained within a jar). This can be problematic if you are looking to distribute a self-contained application.

To solve this problem, many developers use “shaded” jars. A shaded jar simply packages all classes, from all jars, into a single “uber jar”. The problem with shaded jars is that it becomes hard to see which libraries you are actually using in your application. It can also be problematic if the the same filename is used (but with different content) in multiple jars.

Spring Boot takes a different approach and allows you to actually nest jars directly.

----------------------------------------------------------------------------------------------------------------------------------------
From: https://docs.spring.io/spring-boot/docs/1.1.x/reference/htmlsingle/#getting-started-first-application

10.4 Running the example

Since we have used the spring-boot-starter-parent POM we have a useful run goal that we can use to start the application. Type "mvn spring-boot:run" from the root project directory to start the application:

----------------------------------------------------------------------------------------------------------------------------------------
We can override the default behaviour of spring boot by using the application.properties file. Like we can provide

server.port=8081

to change the default port of the tomcat.

Spring Boot Quick Start 25 - Using application properties

SEE: https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html for list of all configurable properties.

Note: the file name has to be application.properties, otherwise it wont work.

----------------------------------------------------------------------------------------------------------------------------------------

We can create a deafult project structure, including pom.xml, using spring intializr tool (https://start.spring.io/)

The project "myspringbootdata" (committed in git) has been created using this tool.

SEE: Spring Boot Quick Start 22 - Using Spring Initializr

----------------------------------------------------------------------------------------------------------------------------------------

If we add the following dependency in pom.xml:

		<dependency>
			<groupId>org.apache.derby</groupId>
			<artifactId>derby</artifactId>
			<scope>runtime</scope>
		</dependency>
		
Maven will download the necessary apache derby jars and add them to classpath. When we start the application using spring boot, the embedded database is also started. We do not need to provide any dataSource or connection strings in this case, since spring boot, on seeing the apache derby in the classpath, assumes that this is the database to which we need to connect.

SEE: Spring Boot Quick Start 29 - Making Crud Operations with Repository (Also see CrudRepository of Spring Data in this tutorial)

Go through the demo project "myspringbootdata" once. The project somehow does not work with apache derby, but works with h2 database.
----------------------------------------------------------------------------------------------------------------------------------------

Why Spring Boot for microservice. small explaination at the end of 
Spring Boot Quick Start 32 - Packaging and running a Spring Boot app


----------------------------------------------------------------------------------------------------------------------------------------

SEE how to configure datasource in spring boot.







