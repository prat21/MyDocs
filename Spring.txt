Reference:
https://docs.spring.io/spring-framework/docs/current/reference/html/
https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#spring-core
-----------------------------------------------------------------------------
Factory Design Pattern (Spring uses factory pattern):

https://www.journaldev.com/1392/factory-design-pattern-in-java
https://www.tutorialspoint.com/design_pattern/factory_pattern.htm

Factory Design Pattern Examples in JDK
1. java.util.Calendar, ResourceBundle and NumberFormat getInstance() methods uses Factory pattern.
2. valueOf() method in wrapper classes like Boolean, Integer etc.

Factory Design Pattern Advantages
1. Factory design pattern provides approach to code for interface rather than implementation.
2. Factory pattern removes the instantiation of actual implementation classes from client code. Factory pattern makes our code more robust, less coupled and easy to extend. For example, we can easily change PC class implementation because client program is unaware of this.
3. Factory pattern provides abstraction between implementation and client classes through inheritance
-------Mine---------
4. Factory pattern removes the complexity of creating an object. Suppose an object needs ten dependencies to be created and injected into it. Writing the code by ourselves for this can be very tedious. If we give this responsibililty to a factory method, then our code will be clean and we dont need to write the code every time we need an instance of the class. Spring uses the same concept.

---------------------------------------------------------------------------------------------
Inversion of control (IOC) and Dependency Injection (DI):

Inversion of Control:

Here is an informal definition of IoC: “IoC is when you have someone else create objects for you.” So instead of writing “new MyObject” in your code, the object is created by someone else. This "someone else" is normally referred to as an IoC container.

This simple explanation illustrates some very important ideas:

1. It is called IoC because control of the object is inverted. It is not the programmer, but someone else who controls the object.
2. IoC is relative in the sense that it only applies to some objects of the application. So there may be IoC for some objects, whereas others are under the direct control of the programmer.

Apart from Spring, there are other examples of IoC like Java Servlets.

The Details:

Let’s delve a little more into the definition of IoC. IoC is much more than object creation: a Spring Context or a Servlet Container not only create objects, but manage their entire lifecycle. That includes creating objects, destroying them, and invoking certain methods of the object at different stages of its lifecycle.

Another thing to consider is that, although programmers relinquish their control on the objects, they still need to define the templates used by the IoC container to create said objects.

For instance, in Spring, classes are annotated with @Service or @Component (among many others) to indicate that the Spring Container is to manage the instances of those classes (it is also possible to use XML configuration instead of annotations).

In a Servlet application, any class implementing the Servlet interface will be managed by the Servlet Container. (We never create an instance of servlet ourselves, like Servlet servlet=new HttpServlet(). The servlet container creates it for us.)

Here is a quick summary of the ideas discussed so far:

1. IoC containers control and manage the lifecycle of some objects: creation, destruction, and callback invocations.
2. The programmer must identify the classes whose instances are to be managed by the IoC container. There are several ways to do this: with annotations, by extending some specific classes, using external configuration.
3. The programmer can influence, to some extent, the way the objects are managed by the IoC container. Normally, this is achieved by overriding the default behavior of the object callbacks.


Inversion of Control and Dependency Injection Playing Together:

We just discussed the issue of managing hundreds of dependencies in a real-life application, possibly with very complicated dependency graphs.
So here is where IoC comes to the rescue. With IoC, the dependencies are managed by the container, and the programmer is relieved of that burden.

Using annotations like @Autowired, the container is asked to inject a dependency where it is needed, and the programmers do not need to create/manage those dependencies by themselves.

SEE: https://dzone.com/articles/ioc-vs-di for Dependency Injection and IOC (it is good)

--------------------------------------------------------------------------------------------
Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies.
Setter injection overrides the constructor injection.
Setter Injection: IoC Container first creates the dependent object then the Target Class Object
Constructor Injection: IoC Container first create the target class object then the dependent object
Constructor based injection helps to implement immutable objects.
https://community.sap.com/t5/application-development-blog-posts/why-not-to-use-field-injection-in-spring-boot/ba-p/13578220#:~:text=Field%20injection%20makes%20your%20beans,constructed%2C%20its%20dependencies%20remain%20unchanged.&text=Here%2C%20the%20userRepository%20reference%20can,created%2C%20breaking%20the%20immutability%20principle.
Field injection makes your beans mutable post-construction. With constructor injection, once an object is constructed, its dependencies remain unchanged.
An @Autowired annotated constructor, setter or field does not have to be public.

check archived chatgpt "spring bean name vs qualifier"
---------------------------------------------------------------------------------------------
Important note on how spring does bean initialization:
1. First spring uses constructor and constructor injection to create a bean. Any autowire candidate that is part of the constructor parameters has to be created before the bean itself is created using constructor.
2. After the bean is created then spring tries to do setter based/factory method based/field based injection. These are for optional dependencies(we can use required=false attribute of autowired annotation to mark a dependency as optional, ie spring will not execute the setter if no autowired candidate is found.). So after the main bean is created then only the beans that are required for setter based(etc) injections are created by spring. The setter based injection can be used to resolve circular dependency also.
3. Order of bean creation steps are:
- Constructor base injection
- Setter based injection(using autowire, including @value annotation)
- @postconstruct

---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-dependson.html
check archived chatgpt "@DependsOn annotation usage"
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-lazy-init.html
https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-method-injection.html
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-autowire.html

limitations and disadvantages of autowiring:
1. Explicit dependencies in property and constructor-arg settings always override autowiring. You cannot autowire simple properties such as primitives, Strings, and Classes (and arrays of such simple properties). This limitation is by-design.
2. Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results. The relationships between your Spring-managed objects are no longer documented explicitly.
3. Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Map instances, this is not necessarily a problem. However, for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html
As a rule, you should use the prototype scope for all stateful beans and the singleton scope for stateless beans.

Spring does not manage the complete lifecycle of a prototype bean. The container instantiates, configures, and otherwise assembles a prototype object and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype beans hold.

Why spring does not manage destroy callback for prototype?
Spring relinquishes control over prototype instances once they're handed to the client. The container has no way to track when a prototype instance is no longer needed, since it doesn't retain references to individual prototype instances.

https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-sing-prot-interaction
You cannot dependency-inject a prototype-scoped bean into your singleton bean, because that injection occurs only once, when the Spring container instantiates the singleton bean and resolves and injects its dependencies. If you need a new instance of a prototype bean at runtime more than once, see Method Injection.

Check archived chatgpt "bean scopes in spring"

https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html#beans-factory-scopes-other-injection
By default, when the Spring container creates a proxy for a bean that is marked up with the <aop:scoped-proxy/> element, a CGLIB-based class proxy is created.
Alternatively, you can configure the Spring container to create standard JDK interface-based proxies for such scoped beans, by specifying false for the value of the proxy-target-class attribute of the <aop:scoped-proxy/> element. Using JDK interface-based proxies means that you do not need additional libraries in your application classpath to affect such proxying. However, it also means that the class of the scoped bean must implement at least one interface and that all collaborators into which the scoped bean is injected must reference the bean through one of its interfaces.

https://docs.spring.io/spring-framework/reference/core/aop/proxying.html
Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object. JDK dynamic proxies are built into the JDK, whereas CGLIB is a common open-source class definition library (repackaged into spring-core).

 If the target object to be proxied implements at least one interface, a JDK dynamic proxy is used, and all of the interfaces implemented by the target type are proxied. If the target object does not implement any interfaces, a CGLIB proxy is created which is a runtime-generated subclass of the target type.

check archived chatgpt "spring scoped proxies"
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html
Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:
1. Methods annotated with @PostConstruct
2. afterPropertiesSet() as defined by the InitializingBean callback interface
3. A custom configured init() method

Destroy methods are called in the same order:
1. Methods annotated with @PreDestroy
2. destroy() as defined by the DisposableBean callback interface
3. A custom configured destroy() method

If you use Spring’s IoC container in a non-web application environment (for example, in a rich client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. You must still configure and implement these destroy callbacks correctly.

When an ApplicationContext creates an object instance that implements the org.springframework.context.ApplicationContextAware interface, the instance is provided with a reference to that ApplicationContext.
Autowiring is another alternative to obtain a reference to the ApplicationContext.

Check archived chatgpt "spring singleton thread safety", "spring postconstruct predestroy use"
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/factory-extension.html
for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as InitializingBean.afterPropertiesSet() or any declared init method) are called, and after any bean initialization callbacks.
An ApplicationContext automatically detects any beans that are defined in the configuration metadata that implement the BeanPostProcessor interface. The ApplicationContext registers these beans as post-processors so that they can be called later, upon bean creation.
An example is the AutowiredAnnotationBeanPostProcessor, which processes the @Autowired annotation. This post processor is used to autowire annotated fields, setter methods, but not autowiring constructors, since this is a BeanPostProcessor which comes into action after a particular bean has been created(using constructor) and before/after initialization.

check archived chatgpt "BeanPostProcessor proxy creation"

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html
Typically, post-processors that populate beans via marker interfaces or the like will implement postProcessBeforeInitialization(java.lang.Object, java.lang.String), while post-processors that wrap beans with proxies will normally implement postProcessAfterInitialization(java.lang.Object, java.lang.String).

check archived chatgpt "spring post-processor beans"
Check "High-level spring Bean lifecycle"

BeanFactoryPostProcessor operates on the bean configuration metadata. That is, the Spring IoC container lets a BeanFactoryPostProcessor read the configuration metadata and potentially change it before the container instantiates any beans.
Spring includes a number of predefined bean factory post-processors, such as PropertyOverrideConfigurer and PropertySourcesPlaceholderConfigurer.
You can use the PropertySourcesPlaceholderConfigurer to externalize property values from a bean definition in a separate file by using the standard Java Properties format. Doing so enables the person deploying an application to customize environment-specific properties, such as database URLs and passwords.
The PropertySourcesPlaceholderConfigurer not only looks for properties in the Properties file you specify. By default, if it cannot find a property in the specified properties files, it checks against Spring Environment properties and regular Java System properties.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/annotation-config.html
Spring uses BeanPostProcessors(AutowiredAnnotationBeanPostProcessor) in conjunction with annotations to make the core IOC container aware of specific annotations.
The <context:annotation-config/> element implicitly registers this post-processor.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired.html
As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with @Autowired in order to instruct the container which one to use.

You can also instruct Spring to provide all beans of a particular type from the ApplicationContext by adding the @Autowired annotation to a field or method that expects an array of that type, as the following example shows:
public class MovieRecommender {
	@Autowired
	private MovieCatalog[] movieCatalogs;
}

Even typed Map instances can be autowired as long as the expected key type is String. The map values contain all beans of the expected type, and the keys contain the corresponding bean names, as the following example shows:
public class MovieRecommender {

	private Map<String, MovieCatalog> movieCatalogs;

	@Autowired
	public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
		this.movieCatalogs = movieCatalogs;
	}
}

A non-required method will not be called at all if its dependency (or one of its dependencies, in case of multiple arguments) is not available. A non-required field will not get populated at all in such cases, leaving its default value in place.

Only one constructor of any given bean class may declare @Autowired with the required attribute set to true, indicating the constructor to autowire when used as a Spring bean. As a consequence, if the required attribute is left at its default value true, only a single constructor may be annotated with @Autowired. If multiple constructors declare the annotation, they will all have to declare required=false.
Note that an annotated constructor does not have to be public.

Alternatively, you can express the non-required nature of a particular dependency through Java 8’s java.util.Optional, as the following example shows:

public class SimpleMovieLister {

	@Autowired
	public void setMovieFinder(Optional<MovieFinder> movieFinder) {
		...
	}
}
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired-primary.html
@Primary indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/autowired-qualifiers.html
Qualifiers do not have to be unique. For example, you can define multiple MovieCatalog beans with the same qualifier value “action”, all of which are injected into a Set<MovieCatalog> annotated with @Qualifier("action").
JSR-250 @Resource annotation which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process. @Autowired has rather different semantics: after selecting candidate beans by type, the specified String qualifier value is considered within those type-selected candidates only.
@Autowired applies to fields, constructors, and multi-argument methods, allowing for narrowing through qualifier annotations at the parameter level. In contrast, @Resource is supported only for fields and bean property setter methods with a single argument.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/resource.html

@Resource takes a name attribute. By default, Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics.
If no name is explicitly specified, the default name is derived from the field name or setter method.

In the following example, the customerPreferenceDao field first looks for a bean named "customerPreferenceDao" and then falls back to a primary type match for the type CustomerPreferenceDao:
public class MovieRecommender {

	@Resource
	private CustomerPreferenceDao customerPreferenceDao;

	@Resource
	private ApplicationContext context;

	public MovieRecommender() {
	}
}

@Autowired annotation first tries to inject by type and then by name if more than one bean of the same type is found.
@Resource annotation first tries to inject by name and then by type if no bean with the specified name is found.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/annotation-config/value-annotations.html

When configuring a PropertySourcesPlaceholderConfigurer using JavaConfig, the @Bean method must be static. Note: Maybe because the PropertySourcesPlaceholderConfigurer is a BeanFactoryPostProcessor which gets invoked before bean creation.

Spring Boot configures by default a PropertySourcesPlaceholderConfigurer bean that will get properties from application.properties and application.yml files.

Built-in converter support provided by Spring allows simple type conversion (to Integer or int for example) to be automatically handled. Multiple comma-separated values can be automatically converted to String array without extra effort.

Note: Like @Resource, the @PostConstruct and @PreDestroy annotation types were a part of the standard Java libraries from JDK 6 to 8. However, the entire javax.annotation package got separated from the core Java modules in JDK 9 and eventually removed in JDK 11. As of Jakarta EE 9, the package lives in jakarta.annotation now. If needed, the jakarta.annotation-api artifact needs to be obtained via Maven Central now, simply to be added to the application’s classpath like any other library.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/classpath-scanning.html

You can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects.
@Repository is already supported as a marker for automatic exception translation in your persistence layer.
The @RestController annotation from Spring MVC is composed of @Controller and @ResponseBody.
To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, with the basePackages attribute.
Furthermore, the AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor are both implicitly included when you use the component-scan element.
By default, classes annotated with @Component, @Repository, @Service, @Controller, @Configuration, or a custom annotation that itself is annotated with @Component are the only detected candidate components. However, you can modify and extend this behavior by applying custom filters. Add them as includeFilters or excludeFilters attributes of the @ComponentScan annotation.
Spring components can also contribute bean definition metadata to the container. You can do this with the same @Bean annotation used to define bean metadata within @Configuration annotated classes.
Autowired fields and methods are supported, as previously discussed, with additional support for autowiring of @Bean methods.
    @Bean
	protected TestBean protectedInstance(
			@Qualifier("public") TestBean spouse,
			@Value("#{privateInstance.age}") String country) {
		TestBean tb = new TestBean("protectedInstance", 1);
		tb.setSpouse(spouse);
		tb.setCountry(country);
		return tb;
	}
	@Bean
    private TestBean privateInstance() {
    	return new TestBean("privateInstance", i++);
    }
The example autowires the String method parameter country to the value of the age property on another bean named privateInstance.

You may declare @Bean methods as static, allowing for them to be called without creating their containing configuration class as an instance. This makes particular sense when defining post-processor beans (for example, of type BeanFactoryPostProcessor or BeanPostProcessor), since such beans get initialized early in the container lifecycle and should avoid triggering other parts of the configuration at that point.

For Spring stereotype annotations, if you supply a name via the annotation’s value attribute that name will be used as the name in the corresponding bean definition. This convention also applies when the following JSR-250 and JSR-330 annotations are used instead of Spring stereotype annotations: @jakarta.annotation.ManagedBean, @javax.annotation.ManagedBean, @jakarta.inject.Named, and @javax.inject.Named.

A different scope can be specified by the @Scope annotation.

The AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor are both implicitly included when you use the component-scan element.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/standard-annotations.html

As with @Autowired, you can use @Inject at the field level, method level and constructor-argument level.
If you would like to use a qualified name for the dependency that should be injected, you should use the @Named annotation.
As with @Autowired, @Inject can also be used with java.util.Optional or @Nullable. This is even more applicable here, since @Inject does not have a required attribute.
Instead of @Component, you can use @jakarta.inject.Named or jakarta.annotation.ManagedBean.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/java/basic-concepts.html

@Configuration classes let inter-bean dependencies be defined by calling other @Bean methods in the same class(Same class because this is achieved by proxy).

When @Bean methods are declared within classes that are not annotated with @Configuration, they are referred to as being processed in a "lite" mode. In such scenarios, @Bean methods are effectively a general-purpose factory method mechanism without special runtime processing (that is, without generating a CGLIB subclass for it). A custom Java call to such a method will not get intercepted by the container and therefore behaves just like a regular method call, creating a new instance every time rather than reusing an existing singleton (or scoped) instance for the given bean.
As a consequence, @Bean methods on classes without runtime proxying are not meant to declare inter-bean dependencies at all.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/java/instantiating-container.html

In much the same way that Spring XML files are used as input when instantiating a ClassPathXmlApplicationContext, you can use @Configuration classes as input when instantiating an AnnotationConfigApplicationContext. This allows for completely XML-free usage of the Spring container.

public static void main(String[] args) {
	ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
	MyService myService = ctx.getBean(MyService.class);
	myService.doStuff();
}

To enable component scanning, you can annotate your @Configuration class as follows:
@Configuration
@ComponentScan(basePackages = "com.acme")
public class AppConfig  {
	// ...
}

AnnotationConfigApplicationContext exposes the scan(String...) method to allow for the same component-scanning functionality, as the following example shows:

public static void main(String[] args) {
	AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
	ctx.scan("com.acme");
	ctx.refresh();
	MyService myService = ctx.getBean(MyService.class);
}
Remember that @Configuration classes are meta-annotated with @Component, so they are candidates for component-scanning. In the preceding example, assuming that AppConfig is declared within the com.acme package (or any package underneath), it is picked up during the call to scan(). Upon refresh(), all its @Bean methods are processed and registered as bean definitions within the container.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/java/bean-annotation.html

We can also use default methods to define beans. This allows composition of bean configurations by implementing interfaces with bean definitions on default methods.
public interface BaseConfig {

	@Bean
	default TransferServiceImpl transferService() {
		return new TransferServiceImpl();
	}
}

@Configuration
public class AppConfig implements BaseConfig {
}

You can also declare your @Bean method with an interface (or base class) return type, as the following example shows:
@Configuration
public class AppConfig {

	@Bean
	public TransferService transferService() {      //Return type is an interface.
		return new TransferServiceImpl();
	}
}

By default, beans defined with Java configuration that have a public close or shutdown method are automatically enlisted with a destruction callback. If you have a public close or shutdown method and you do not wish for it to be called when the container shuts down, you can add @Bean(destroyMethod = "") to your bean definition to disable the default (inferred) mode.

The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML’s init-method and destroy-method attributes on the bean element, as the following example shows:

@Configuration
public class AppConfig {
    @Bean(initMethod = "init", destroyMethod = "cleanup")
    public Thing thing() {
        return new Thing();
    }
}

By default, configuration classes use a @Bean method’s name as the name of the resulting bean. This functionality can be overridden, however, with the name attribute.
@Configuration
public class AppConfig {

	@Bean("myThing")
	public Thing thing() {
		return new Thing();
	}
}

Note: @qualifier is more like a filter to choose a bean among multiple beans of same type. But @bean name is the actual name of the bean in the spring container. Multiple beans can have same qualifier but bean names have to be unique.

It is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The name attribute of the @Bean annotation accepts a String array for this purpose.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/java/configuration-annotation.html

When beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another.
@Configuration
public class AppConfig {

	@Bean
	public BeanOne beanOne() {
		return new BeanOne(beanTwo());
	}

	@Bean
	public BeanTwo beanTwo() {
		return new BeanTwo();
	}
}

This method of declaring inter-bean dependencies works only when the @Bean method is declared within a @Configuration class. You cannot declare inter-bean dependencies by using plain @Component classes.

@Configuration
public class AppConfig {

	@Bean
	public ClientService clientService1() {
		ClientServiceImpl clientService = new ClientServiceImpl();
		clientService.setClientDao(clientDao());
		return clientService;
	}

	@Bean
	public ClientService clientService2() {
		ClientServiceImpl clientService = new ClientServiceImpl();
		clientService.setClientDao(clientDao());
		return clientService;
	}

	@Bean
	public ClientDao clientDao() {
		return new ClientDaoImpl();
	}
}
clientDao() has been called once in clientService1() and once in clientService2(). Since this method creates a new instance of ClientDaoImpl and returns it, you would normally expect to have two instances (one for each service). That definitely would be problematic: In Spring, instantiated beans have a singleton scope by default. This is where the magic comes in: All @Configuration classes are subclassed at startup-time with CGLIB. In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance.

There are a few restrictions due to the fact that CGLIB dynamically adds features at startup-time. In particular, configuration classes must not be final.
All @Configuration classes are subclassed at startup-time with CGLIB. In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/java/composing-configuration-classes.html

The @Import annotation allows for loading @Bean definitions from another configuration class.

The @Profile annotation is actually implemented by using a much more flexible annotation called @Conditional. The @Conditional annotation indicates specific org.springframework.context.annotation.Condition implementations that should be consulted before a @Bean is registered.
---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/environment.html

The @Profile annotation lets you indicate that a component is eligible for registration when one or more specified profiles are active.
@Profile({"p1", "p2"}), that class is not registered or processed unless profiles 'p1' or 'p2' have been activated.

@Profile can also be declared at the method level.
You can activate multiple profiles at once.
-Dspring.profiles.active="profile1,profile2"
The default profile represents the profile that is enabled if no profile is active.

A PropertySource is a simple abstraction over any source of key-value pairs, and Spring’s StandardEnvironment is configured with two PropertySource objects — one representing the set of JVM system properties (System.getProperties()) and one representing the set of system environment variables (System.getenv()).
These default property sources are present for StandardEnvironment, for use in standalone applications. StandardServletEnvironment is populated with additional default property sources including servlet config, servlet context parameters, and a JndiPropertySource if JNDI is available.

For a common StandardServletEnvironment, the full hierarchy is as follows, with the highest-precedence entries at the top:
1. ServletConfig parameters (if applicable - for example, in case of a DispatcherServlet context)
2. ServletContext parameters (web.xml context-param entries)
3. JNDI environment variables (java:comp/env/ entries)
4. JVM system properties (-D command-line arguments)
5. JVM system environment (operating system environment variables)

Spring’s Environment abstraction provides search operations over a configurable hierarchy of property sources.
The @PropertySource annotation provides a convenient and declarative mechanism for adding a PropertySource to Spring’s Environment.

@Configuration
@PropertySource("classpath:/com/myco/app.properties")
public class AppConfig {

 @Autowired
 Environment env;

 @Bean
 public TestBean testBean() {
  TestBean testBean = new TestBean();
  testBean.setName(env.getProperty("testbean.name"));
  return testBean;
 }
}

Any ${...} placeholders present in a @PropertySource resource location are resolved against the set of property sources already registered against the environment(for example, system properties or environment variables).

---------------------------------------------------------------------------------------------
https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html

ContextRefreshedEvent: Published when the ApplicationContext is initialized or refreshed (for example, by using the refresh() method on the ConfigurableApplicationContext interface). Here, “initialized” means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the ApplicationContext object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen ApplicationContext actually supports such “hot” refreshes. For example, XmlWebApplicationContext supports hot refreshes, but GenericApplicationContext does not.

You can register an event listener on any method of a managed bean by using the @EventListener annotation.
public class BlockedListNotifier {

	private String notificationAddress;

	public void setNotificationAddress(String notificationAddress) {
		this.notificationAddress = notificationAddress;
	}

	@EventListener
	public void processBlockedListEvent(BlockedListEvent event) {
		// notify appropriate parties via notificationAddress...
	}
}
The method signature once again declares the event type to which it listens, but, this time, with a flexible name and without implementing a specific listener interface.
If your method should listen to several events or if you want to define it with no parameter at all, the event types can also be specified on the annotation itself.

@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
	// ...
}

The following example shows how our notifier can be rewritten to be invoked only if the content attribute of the event is equal to my-event:

@EventListener(condition = "#blEvent.content == 'my-event'")
public void processBlockedListEvent(BlockedListEvent blEvent) {
	// notify appropriate parties via notificationAddress...
}
---------------------------------------------------------------------------------------------
In order for spring to inject a property into an object, one of the following has to satisfy:
1. the property has a setter method, regardless of whether it is private or public.
2. the property is a constructor argument of the object so that it can be injected as a constructor-arg, regardless of whether it is private or public.

Even if the property is public, it cannot be injected if it does not have a setter and it is not a constructor argument of the object.

While using @Autowired annotation though, a property does not necessarily need to have a setter if it is marked by @autowired, spring can inject the property regardless of whether the setter is present or not. Spring uses reflection in case of private fields having no setters or constructor args.

@Autowired can be applied on top of a field, setter method (not getter, since properties are injected via setter) or on top of constructor(for autowire by constructor).
https://www.baeldung.com/constructor-injection-in-spring

Check archived chatgpt "Spring autowiring process"
---------------------------------------------------------------------------------------------
1. Triangle.java:

public class Triangle {
	private String type;
	private int height;
	
	/*public Triangle() {
		
	}*/
	
	public Triangle(String type,int height) {
		this.type = type;
		this.height = height;
	}

	public int getHeight() {
		return height;
	}

	public void setHeight(int height) {
		this.height = height;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}
	
	public void draw() {
		System.out.println(getType()+" triangle of height "+getHeight()+" is drawn");
	}
}


2. spring.xml:

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="triangle" class="com.spring.spring1.Triangle">
 		<property name="type" value="equilateral"/>
 	</bean>  
</beans>

3. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");
        
        triangle.draw();
    }
}


Output: Could not instantiate bean class [com.spring.spring1.Triangle]: No default constructor found;
Uncomment the default constructor above and re-run,the program will run successfully.

---------------------------------------------------------------------------------------------
The above example with spring.xml changed as:

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="triangle" class="com.spring.spring1.Triangle">
 		<constructor-arg name="type" value="equilateral"/>
 		<constructor-arg name="height" value="20t"/>
 	</bean>  
</beans>

Ouput: Error creating bean with name 'triangle' defined in class path resource [spring.xml]: Could not resolve matching constructor.
Since there are no constructors with two strings as arguments.

---------------------------------------------------------------------------------------------

1. Triangle.java:

package com.spring.spring1;

public class Triangle {
	private String type;
	private int height;
	
	public Triangle(String type) {
		this.type = type;
	}
	
	public Triangle(int height) {
		this.height = height;
	}
	
	public Triangle(String type,int height) {
		this.type = type;
		this.height = height;
	}

	public int getHeight() {
		return height;
	}

	public void setHeight(int height) {
		this.height = height;
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}
	
	public void draw() {
		System.out.println(getType()+" triangle of height "+getHeight()+" is drawn");
	}
}


2. spring.xml:

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="triangle" class="com.spring.spring1.Triangle">
 		<constructor-arg value="20"/>
 	</bean>  
</beans>

3. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");
        
        triangle.draw();
    }
}


Output: 20 triangle of height 0 is drawn

Since there is no type defined in the constructor-arg, hence spring will interpret "20" as string and set the type as 20.
We can explicitly mention the type of constructor-arg in the spring.xml.


<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="triangle" class="com.spring.spring1.Triangle">
 		<constructor-arg value="20" type="int"/>
 	</bean>  
</beans>


This will call the constructor with int parameter and print "null triangle of height 20 is drawn". (null because we have not set the type of the triangle)

---------------------------------------------------------------------------------------------
We can arrange the constructor parameters using their argument names.

Same Triangle.java and App.java as above.

Spring.xml:

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">

	<bean id="triangle" class="com.spring.spring1.Triangle">
 		<constructor-arg value="20" name="height"/>
 		<constructor-arg value="equilateral" name="type"/>
 	</bean>  
</beans>

Output: equilateral triangle of height 20 is drawn.

---------------------------------------------------------------------------------------------

Autowiring:

1. byname - autowires using the names (id) of the beans.
2. bytype - autowires using the type of the bean and the property. If there are multiple beans of the same type defined in the spring.xml then it will fail.
3. constructor - same as autowire bytype, but instead of injecting the beans using setter methods it uses constructors to inject the beans. But again, the argument types of the constructor has to be different. If there are more than one argument of same type in constructor and more than one bean with same type in spring.xml, then autowiring by constructor will fail.

---------------------------------------------------------------------------------------------
Singleton Pattern in java:

https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples

---------------------------------------------------------------------------------------------
Spring bean scopes:

1. Singleton: If the bean scope is singleton, then spring creates the instance of that bean while intialization of the spring container (ie ApplicationContext). It does not wait for the getBean method call by an object.
2. Prototype: If the bean scope is prototype, then the spring creates the instance of that bean only when the getBean method is called by some object. This type of bean is not intstantiated while spring container starts.

---------------------------------------------------------------------------------------------

Difference between spring singleton and java singleton:

https://stackoverflow.com/questions/15252284/what-is-the-difference-between-a-spring-singleton-and-a-java-singeletondesign-p
https://dzone.com/articles/an-interview-question-on-spring-singletons  (this is good.)


---------------------------------------------------------------------------------------------

1. Triangle.java:

package com.spring.spring1;

public class Triangle {
	Point pointA;
	Point pointB;
	Point pointC;
	
	public Point getPointA() {
		return pointA;
	}

	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}

	public Point getPointB() {
		return pointB;
	}

	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}

	public Point getPointC() {
		return pointC;
	}

	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		System.out.println("PointA:"+getPointA().getX()+","+getPointA().getY());
		System.out.println("PointB:"+getPointB().getX()+","+getPointB().getY());
		System.out.println("PointC:"+getPointC().getX()+","+getPointC().getY());
	}
}


2. Spring.xml:

<bean id="triangle" class="com.spring.spring1.Triangle">
 		<property name="pointA" ref="zeroPoint"/>
 		<property name="pointB" ref="Point2"/>
 		<property name="pointC" ref="Point3"/>
 	</bean>  
 	
 	<bean id="zeroPoint" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>

Note that the triangle bean is singleton but the pointA,pointB and pointC beans are prototype.

3. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");
        
        System.out.println(triangle.getPointA());
        System.out.println(triangle.getPointB());
        System.out.println(triangle.getPointC());
        System.out.println("----------------------------");
        System.out.println(context.getBean("zeroPoint"));
        System.out.println(context.getBean("Point2"));
        System.out.println(context.getBean("Point3"));
    }
}

Output: 
com.spring.spring1.Point@68c4039c
com.spring.spring1.Point@ae45eb6
com.spring.spring1.Point@59f99ea
----------------------------
com.spring.spring1.Point@27efef64
com.spring.spring1.Point@6f7fd0e6
com.spring.spring1.Point@47c62251

That is, since pointA,B and C beans are prototype, everytime we call getbean, a new instance is created. Initially when the triangle bean is created while loading the spring conatiner (since it is singleton), instances of pointA,B and C is created and injected into triangle. But when we call getBean on those point beans afterwards, since they are prototype, new instances are created and returned.

---------------------------------------------------------------------------------------------

Bean Definition Inheritance:

1. Triangle.java:

package com.spring.spring1;

public class Triangle {
	Point pointA;
	Point pointB;
	Point pointC;
	
	public Point getPointA() {
		return pointA;
	}

	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}

	public Point getPointB() {
		return pointB;
	}

	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}

	public Point getPointC() {
		return pointC;
	}

	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		System.out.println("PointA:"+getPointA().getX()+","+getPointA().getY());
		System.out.println("PointB:"+getPointB().getX()+","+getPointB().getY());
		System.out.println("PointC:"+getPointC().getX()+","+getPointC().getY());
	}
}

2. Spring.xml:

	<bean id="parenttriangle" class="com.spring.spring1.Triangle">
 		<property name="pointA" ref="zeroPoint"/>
 	</bean> 
	
	<bean id="triangle1" class="com.spring.spring1.Triangle" parent="parenttriangle">
 		<property name="pointB" ref="Point2"/>
 		<property name="pointC" ref="Point3"/>
 	</bean>
 	
 	<bean id="triangle2" class="com.spring.spring1.Triangle" parent="parenttriangle">
 		<property name="pointB" ref="Point2"/>
 	</bean> 
 	
 	<bean id="zeroPoint" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
	
	
3. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle1");
        
        triangle.draw();
        System.out.println("----------------------------------------");
        triangle = (Triangle) context.getBean("triangle2");
        triangle.draw();
    }
}


Output:
PointA:0,0
PointB:20,0
PointC:0,-20
----------------------------------------
PointA:0,0
PointB:20,0
java.lang.NullPointerException
	at com.spring.spring1.Triangle.draw(Triangle.java:35)
	at com.spring.spring1.App.main(App.java:20)

This is because "traingle1" inherits pointA from parenttriangle and it has pointB and C defined. But triangle2 inherits from parenttriangle and it has pointB but not pointC. Hence the null pointer exception.


If we change the spring.xml like this:

	<bean id="parenttriangle" class="com.spring.spring1.Triangle">
 		<property name="pointA" ref="zeroPoint"/>
 	</bean> 
	
	<bean id="triangle1" class="com.spring.spring1.Triangle" parent="parenttriangle">
 		<property name="pointA" ref="Point2"/>
		<property name="pointB" ref="Point2"/>
 		<property name="pointC" ref="Point3"/>
 	</bean>
 	
 	<bean id="triangle2" class="com.spring.spring1.Triangle" parent="parenttriangle">
 		<property name="pointB" ref="Point2"/>
 	</bean> 
 	
 	<bean id="zeroPoint" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
 
 and App.java:
 
 public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle1");
        
        triangle.draw();
    }
}
	
Then output: PointA:20,0
PointB:20,0
PointC:0,-20

That is we can override the inherited property in the child bean, just like we override the pointA property inherited from parettriangle in triangle1 bean.

-------------------------------------------------------------------------------------------------------------------------------------------------

Bean Definition Inheritance with Collections:

if spring.xml:

	<bean id="parenttriangle" class="com.spring.spring1.Triangle">
 		<property name="points">
 			<list>
 				<ref bean="zeroPoint"/>
 			</list>
 		</property>
 	</bean> 
	
	<bean id="triangle1" class="com.spring.spring1.Triangle" parent="parenttriangle">
		<property name="points">
 			<list>
 				<ref bean="Point2"/>
 			</list>
 		</property>
 	</bean>
 	
 	 	
 	<bean id="zeroPoint" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
</beans>

Then the "points" property of triangle1 overrides the "points" property of parenttriangle, ie the list "points" of triangle1 looks like [Point2].
But if spring.xml is:

	<bean id="parenttriangle" class="com.spring.spring1.Triangle">
 		<property name="points">
 			<list>
 				<ref bean="zeroPoint"/>
 			</list>
 		</property>
 	</bean> 
	
	<bean id="triangle1" class="com.spring.spring1.Triangle" parent="parenttriangle">
		<property name="points">
 			<list merge="true">
 				<ref bean="Point2"/>
 			</list>
 		</property>
 	</bean>
 	
 	 	
 	<bean id="zeroPoint" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.spring1.Point" scope="prototype">
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
	
Then the list "points" of triangle1 is merged with that of parenttriangle, ie now the list "points" of triangle1 contains [zeroPoint,Point2].

-------------------------------------------------------------------------------------------------------------------------------------------------

Bean Definition Inheritance:

If spring.xml:

	<bean id="parenttriangle" class="com.spring.spring1.Triangle" abstract="true">
 		<property name="points">
 			<list>
 				<ref bean="zeroPoint"/>
 			</list>
 		</property>
 	</bean>

Then spring container uses the parenttriangle bean as template only and does not make an instance of that bean.

-----------------------------------------------------------------------------------------------------------------------------------------------------

Spring Bean LifeCycle CallBacks:

There are couple of ways to implement life cycle call backs for spring beans:
1. By implementing InitializingBean and DisposableBean interface and implementing their methods (afterPropertiesSet and destroy).
2. Or by handling it in xml level. We can set the "init-method" and "destroy-method" attributes of a <bean> tag to set it for a particular bean or the "default-init-method" and "default-destroy-method" of the <beans> tag to set it globally so that the init and destroy method is set globally for all bean tags.
(The second method is preferable since we do not have to implement any interface and tie our class to spring framework).

If we apply both of the above methods, then the interface methods will be called first and then the xml init and destroy methods.


Output:
InitializingBean init
init-methods init
PointA:0,0
PointB:20,0
PointC:0,-20
Jul 29, 2018 3:12:42 PM org.springframework.context.support.ClassPathXmlApplicationContext doClose
INFO: Closing org.springframework.context.support.ClassPathXmlApplicationContext@6193b845: startup date [Sun Jul 29 15:12:42 IST 2018]; root of context hierarchy
DisposableBean destroy
destroy-method destroy

If we apply both the "init-method", "destroy-method" methods and the "default-init-method", "default-destroy-method" methods, then the "init-method", "destroy-method" will take priority and the default methods will not execute at all.

-----------------------------------------------------------------------------------------------------------------------------------------------------
BeanPostProcessor interface:

If a common set of code is to be executed after each bean initialization, then this interface can be used. (Note that there is no similar interface for destroy.)

1. Triangle.java:

package com.spring.coreSpring;

public class Triangle{
	Point pointA;
	Point pointB;
	Point pointC;
	
	public Point getPointA() {
		return pointA;
	}

	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}

	public Point getPointB() {
		return pointB;
	}

	public void setPointB(Point pointB) {
		this.pointB = pointB;
	}

	public Point getPointC() {
		return pointC;
	}

	public void setPointC(Point pointC) {
		this.pointC = pointC;
	}

	public void draw() {
		System.out.println("PointA:"+getPointA().getX()+","+getPointA().getY());
		System.out.println("PointB:"+getPointB().getX()+","+getPointB().getY());
		System.out.println("PointC:"+getPointC().getX()+","+getPointC().getY());
	}	
	
}



2. spring.xml:

	<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd" >

	<bean id="triangle" class="com.spring.coreSpring.Triangle" >
 		<property name="pointA" ref="zeroPoint"/>
 		<property name="pointB" ref="Point2"/>
 		<property name="pointC" ref="Point3"/>
 	</bean>  
 	
 	<bean id="zeroPoint" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.coreSpring.Point" >
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
 	
 	<bean class="com.spring.coreSpring.MyBeanPostProcessor"/>		//We need to register the bean, that implements BeanPostProcessor, in spring.xml
</beans>


3. MyBeanPostProcessor.java (that implements BeanPostProcessor)

public class MyBeanPostProcessor implements BeanPostProcessor {

	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("after intialization of "+beanName);
		return bean;
	}

	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("before intialization of "+beanName);
		return bean;
	}

}


4. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");
        
        triangle.draw();
        
    }
}


Output:
before intialization of zeroPoint
after intialization of zeroPoint
before intialization of Point2
after intialization of Point2
before intialization of Point3
after intialization of Point3
before intialization of triangle
after intialization of triangle
PointA:0,0
PointB:20,0
PointC:0,-20

In the method signature of the methods of BeanPostProcessor, the first argument is the bean itself and the second argument is the bean name. We can make changes to the bean in the method and return the modified bean. As a matter of fact, we can return any object from those methods. Lets test:

a) If we return null from those methods:

public class MyBeanPostProcessor implements BeanPostProcessor {

	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("after intialization of "+beanName);
		return null;
	}

	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("before intialization of "+beanName);
		return null;
	}

}

Output:

before intialization of zeroPoint
before intialization of Point2
before intialization of Point3
before intialization of triangle
Exception in thread "main" java.lang.NullPointerException
	at com.spring.coreSpring.App.main(App.java:18)
	

b) If we make some changes to the bean:

public class MyBeanPostProcessor implements BeanPostProcessor {

	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("after intialization of "+beanName);
		if(beanName.contains("Point")) {
			Point beanIsPoint = (Point) bean;
			beanIsPoint.setX(-100);						// If bean is Point then change the x-ordinate to -100 and return the modified bean, else do nothing.
			return beanIsPoint;
		}
		else
			return bean;
		
	}

	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("before intialization of "+beanName);
		return bean;
	}

}


Output:

before intialization of zeroPoint
after intialization of zeroPoint
before intialization of Point2
after intialization of Point2
before intialization of Point3
after intialization of Point3
before intialization of triangle
after intialization of triangle
PointA:-100,0						//x-ordinates modified by BeanPostProcessor
PointB:-100,0
PointC:-100,-20


-----------------------------------------------------------------------------------------------------------------------------------------------------

BeanFactoryPostProcessor and PropertyPlaceHolderConfigurer:

BeanFactoryPostProcessor is an interface which provides methods to be called when the BeanFactory is initialized (Note that ApplicationContext is essentialy a BeanFactory). This method is called even before the beans are initialized or spring.xml is read by the BeanFactory.

1. Triangle.java (same as before)
2. spring.xml:

	<bean id="triangle" class="com.spring.coreSpring.Triangle" >
 		<property name="pointA" ref="zeroPoint"/>
 		<property name="pointB" ref="Point2"/>
 		<property name="pointC" ref="Point3"/>
 	</bean>  
 	
 	<bean id="zeroPoint" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.coreSpring.Point" >
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
 	
 	<bean class="com.spring.coreSpring.MyBeanFactoryPostProcessor"/>	//BeanFactoryPostProcessor has to be registered in the spring.xml so that spring container is aware about its existence.

3. MyBeanFactoryPostProcessor.java

public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

	public void postProcessBeanFactory(ConfigurableListableBeanFactory arg0) throws BeansException {
		System.out.println("Inside my bean factory post processor");

	}

}


4. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");
        
        triangle.draw();
        
    }
}


Output:

Inside my bean factory post processor

Jul 29, 2018 4:13:54 PM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons
INFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@7c30a502: defining beans [triangle,zeroPoint,Point2,Point3,com.spring.coreSpring.MyBeanFactoryPostProcessor#0]; root of factory hierarchy

PointA:0,0
PointB:20,0
PointC:0,-20



PropertyPlaceHolderConfigurer is special type BeanFactoryPostProcessor which is being provided by the spring itself to configure the properties file.

1. spring.xml:

	<bean id="triangle" class="com.spring.coreSpring.Triangle" >
 		<property name="pointA" ref="zeroPoint"/>
 		<property name="pointB" ref="Point2"/>
 		<property name="pointC" ref="Point3"/>
 	</bean>  
 	
 	<bean id="zeroPoint" class="com.spring.coreSpring.Point" >
 		<property name="x" value="${zeroPoint.x}"/>						//Place Holder. The values are defined in spring.properties file
 		<property name="y" value="${zeroPoint.y}"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.coreSpring.Point" >
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
 	
 	<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">			//PropertyPlaceHolderConfigurer
 		<property name="location" value="spring.properties"/>
 	</bean>


2. spring.properties:

zeroPoint.x=0
zeroPoint.y=0

3. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");
        
        triangle.draw();
        
    }
}


Output:
INFO: Loading XML bean definitions from class path resource [spring.xml]
Jul 29, 2018 4:21:22 PM org.springframework.beans.factory.config.PropertyPlaceholderConfigurer loadProperties
INFO: Loading properties file from class path resource [spring.properties]
Jul 29, 2018 4:21:22 PM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons
INFO: Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@7c30a502: defining beans [triangle,zeroPoint,Point2,Point3,org.springframework.beans.factory.config.PropertyPlaceholderConfigurer#0]; root of factory hierarchy
PointA:0,0
PointB:20,0
PointC:0,-20


https://www.baeldung.com/properties-with-spring
-----------------------------------------------------------------------------------------------------------------------------------------------------

@Autowired annotation: It first tries to do autowire bytype and if it fails, then it tries to do autowire byname. If it fails, then other option is to use @Qualifier annotation.

Now there are two ways to use @Qualifier annotation.
1. To use <qualifier> tag inside <bean> tag. And use @Qualifier annotation with name equal to the "value" attribute of the <qualifier> tag.
2. To use the @Qualifier annotation with name equal to the "id" of the bean tag.


First Way:

1. Triangle.java:

package com.spring.coreSpring;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Triangle{
	
	Point pointA;						//For demonstration, we have put only one point.
	
	public Point getPointA() {
		return pointA;
	}

	@Autowired
	@Qualifier("triangleQualifier")
	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public void draw() {
		System.out.println("PointA:"+getPointA().getX()+","+getPointA().getY());
	}	
}


2. spring.xml:

	<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context = "http://www.springframework.org/schema/context"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<bean id="triangle" class="com.spring.coreSpring.Triangle" > 		
 		
 	</bean>  
 	
 	<bean id="zeroPoint" class="com.spring.coreSpring.Point" >
 		<qualifier value="triangleQualifier"/>						//Notice the qualifier tag
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.coreSpring.Point" >
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
 	
 	<context:annotation-config/>									//This is required for the annotations to work
 	
</beans>

3. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");
        
        triangle.draw();
        
    }
}

Output: PointA:0,0



Second way:

1. Triangle.java:

package com.spring.coreSpring;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;

public class Triangle{
	
	Point pointA;						//For demonstration, we have put only one point.
	
	public Point getPointA() {
		return pointA;
	}

	@Autowired
	@Qualifier("zeroPoint")					//We are using the id of a bean as qualifier
	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}


	public void draw() {
		System.out.println("PointA:"+getPointA().getX()+","+getPointA().getY());
	}	
}


2. spring.xml:

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context = "http://www.springframework.org/schema/context"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<bean id="triangle" class="com.spring.coreSpring.Triangle" > 		
 		
 	</bean>  
 	
 	<bean id="zeroPoint" class="com.spring.coreSpring.Point" > 				//Note that there is no qaulifier tag
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.coreSpring.Point" >
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
 	
 	<context:annotation-config/>
 	
</beans>

3. App.java: same

Output: PointA:0,0


Please note that if <qualifier> tag is present, then we have to give the value of the <qualifier> tag in the @Qualifier annotation. If we give the id of the bean tag in the @Qualifier annotation, although the <qualifier> tag is present, then it will not be able to autowire the dependency and throw an error.



-----------------------------------------------------------------------------------------------------------------------------------------------------

JSR-250 annotations:

@Resource: It is similar to @Autowired annotations. Difference is that, it first tries to autowire byname and then bytype.

@Resource (name="somename") is similiar to @Autowired @Qualifier("somename").

Difference between @Resource and @Autowired:
https://stackoverflow.com/questions/4093504/resource-vs-autowired
https://www.linkedin.com/pulse/difference-between-inject-vs-autowire-resource-pankaj-kumar

"@Resource: annotation based on JSR-250. @Resource is quite similar to @Autowired and @Inject (JSR-330 annotation), but the main difference is the execution paths taken to find out the required bean to inject. @Resource will narrow down the search first by name then by type and finally by Qualifiers (ignored if match is found by name). @Autowired and @Inject will narrow down the search first by type then by qualifier and finally by the name."

Since @Resource first matches the beans byname, what if the name is same but the type is different:

1. Triangle.java:

package com.spring.coreSpring;

import javax.annotation.Resource;

public class Triangle{
	
	Point pointA;
	
	public Point getPointA() {
		return pointA;
	}

	@Resource
	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}

	public void draw() {
		System.out.println("PointA:"+getPointA().getX()+","+getPointA().getY());
	}	
	
	
}

2. spring.xml:

<?xml version = "1.0" encoding = "UTF-8"?>

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context = "http://www.springframework.org/schema/context"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<bean id="triangle" class="com.spring.coreSpring.Triangle" >	
 		
 	</bean>  
 	
 	<bean id="pointA" class="com.spring.coreSpring.App" > 		

 	</bean>
 	
 	<bean id="Point2" class="com.spring.coreSpring.Point" >
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
 	
 	<context:annotation-config/>
 	
</beans>



3. App.java:

{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");
        
        triangle.draw();
        
    }
}


Output: org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named 'pointA' must be of type [com.spring.coreSpring.Point], but was actually of type [com.spring.coreSpring.App]


There are two more JSR-250 annotations @PostConstruct and @PreDestroy,which are similar to init-method and destroy-method of spring.xml.
-----------------------------------------------------------------------------------------------------------------------------------------------------

@Component: This annotation is used to register a bean using the class definition itself, rather than declaring the bean in spring.xml.

1. Triangle.java

package com.spring.coreSpring;

import javax.annotation.Resource;

import org.springframework.stereotype.Component;

@Component							//This annotation is going to register this class as bean with id="triangle"
public class Triangle{
	
	Point pointA;
	
	public Point getPointA() {
		return pointA;
	}

	@Resource (name="zeroPoint")
	public void setPointA(Point pointA) {
		this.pointA = pointA;
	}

	public void draw() {
		System.out.println("PointA:"+getPointA().getX()+","+getPointA().getY());
	}	
	
}

2. spring.xml:

<beans xmlns = "http://www.springframework.org/schema/beans"
   xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context = "http://www.springframework.org/schema/context"
   xsi:schemaLocation = "http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

	<!-- <bean id="triangle" class="com.spring.coreSpring.Triangle" > 					//We have commented out since this definition is not required
 		
 	</bean>  --> 
 	
 	<bean id="zeroPoint" class="com.spring.coreSpring.Point" > 		
 		<property name="x" value="0"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point2" class="com.spring.coreSpring.Point" >
 		<property name="x" value="20"/>
 		<property name="y" value="0"/>
 	</bean>
 	
 	<bean id="Point3" class="com.spring.coreSpring.Point" >
 		<property name="x" value="0"/>
 		<property name="y" value="-20"/>
 	</bean>
 	
 	<context:component-scan base-package="com.spring.coreSpring"/>		//Required for spring to scan the package for stereotype annotations like Component,Controller,Repository & Service
 	<context:annotation-config/>
 	
</beans>

3. App.java:

public class App 
{
    public static void main( String[] args )
    {
        ApplicationContext context = new ClassPathXmlApplicationContext("spring.xml");
        Triangle triangle = (Triangle) context.getBean("triangle");							//The name of the bean is going to be name of the class itself (the first letter in lowercase)
        
        triangle.draw();
        
    }
}

Output: PointA:0,0


All the other stereotype annotations do the samething as Component. They are used as metadata and to signify the functionality of a particular class.
-----------------------------------------------------------------------------------------------------------------------------------------------------

Spring JDBCtemplate:


1. JDBC produces a lot of boiler plate code, such as opening/closing a connection to a database, handling sql exceptions etc. It makes the code extremely cumbersome and difficult to read.
2. Implementing JDBC in the Spring Framework takes care of working with many low-level operations (opening/closing connections, executing SQL queries, etc.).
3. Thanks to this, when working with the database in the Spring Framework, we only need to define the connection parameters from the database and register the SQL query, the rest of the work for us is performed by Spring.
4. JDBC in Spring has several classes (several approaches) for interacting with the database. The most common of these is using the JdbcTemplate class. This is the base class that manages the processing of all events and database connections.
5. The JdbcTemplate class executes SQL queries, iterates over the ResultSet, and retrieves the called values, updates the instructions and procedure calls, “catches” the exceptions, and translates them into the exceptions defined in the org.springframwork.dao package.
Instances of the JdbcTemplate class are thread-safe. This means that by configuring a single instance of the JdbcTemplate class, we can then use it for several DAO objects.

Methods:

1)	public int update(String query)	is used to insert, update and delete records.
2)	public int update(String query,Object... args)	is used to insert, update and delete records given arguments.
3)	public void execute(String query)	is used to execute DDL query.
4)	public List query(String sql, RowMapper rse) is used to fetch list of records using RowMapper.
5)  public T queryForObject(String sql, Class<T> requiredType)  Execute a query for a single result object of type "requiredType", given static SQL.


We can create the datasource as (in spring.xml):

<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource" destroy-method="close">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/springjdbc"/>
    <property name="username" value="guest_user"/>
    <property name="password" value="guest_password"/>
</bean>

or in java configuration as:

@Configuration
@ComponentScan("org.baeldung.jdbc")
public class SpringJdbcConfig {
    @Bean
    public DataSource mysqlDataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/springjdbc");
        dataSource.setUsername("guest_user");
        dataSource.setPassword("guest_password");
 
        return dataSource;
    }
}
 
but "DriverManagerDataSource" does not give us the database connection pooling benefits. For each call to the "datasource.getConnection()", it returns a new connection which is not efficient. To use connection pooling benefits we use the apache commons dbcp datasource.

<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/springjdbc"/>
    <property name="username" value="guest_user"/>
    <property name="password" value="guest_password"/>
	<property name="initialSize" value="2"/>
	<property name="maxActive" value="5"/>
</bean>

spring tutorials 39-42
-----------------------------------------------------------------------------------------------------------------------------------------------------

Spring NamedParameterJDBCtemplate:

Same as jdbctemplate but uses named parameter instead of "?" placeholders.

This wraps the JbdcTemplate and provides an alternative to the traditional syntax using “?” to specify parameters. Under the hood, it substitutes the named parameters to JDBC “?” placeholder and delegates to the wrapped JDCTemplate to execute the queries.

SqlParameterSource:

It is an object to pass the named parameters into the NamedParameterJDBCtemplate. Like: 

SqlParameterSource namedParameters = new MapSqlParameterSource().addValue("id", 1);
return namedParameterJdbcTemplate.queryForObject("SELECT FIRST_NAME FROM EMPLOYEE WHERE ID = :id", namedParameters, String.class); //String.class is the return type

Also see BeanPropertySqlParameterSource in the below link.

Also see: http://www.baeldung.com/spring-jdbc-jdbctemplate

It has some good examples.

SEE: Spring tutorial 43
-----------------------------------------------------------------------------------------------------------------------------------------------------

Spring DAOSupport classes:

These are support classes to externalize all the common code ,like initializing jdbctemplate with datasource, to an external class. There are 3 support classes, each for jdbcTemplate,NamedParameterJDBCtemplate and SimpleJdbcTemplate.


SEE: spring tutorial 44

-----------------------------------------------------------------------------------------------------------------------------------------------------

Property file using Spring:

https://www.baeldung.com/properties-with-spring
https://dzone.com/articles/properties-spring

Spring 3.1 also introduces the new @PropertySource annotation, as a convenient mechanism of adding property sources to the environment. This annotation is to be used in conjunction with Java based configuration and the @Configuration annotation:

@PropertySource("classpath:/com/foo/foo.properties")

As opposed to using XML namespace element, the Java @PropertySource annotation does not automatically register a PropertySourcesPlaceholderConfigurer with Spring. Instead, the bean must be explicitly defined in the configuration to get the property resolution mechanism working.

1. Before Spring 3.1:
Defining a <context:property-placeholder> XML element automatically registers a new PropertyPlaceholderConfigurer bean in the Spring Context.

2. In Spring 3.1:
From Spring 3.1 onward, the XML <context:property-placeholder> will no longer register the old PropertyPlaceholderConfigurer but the newly introduced PropertySourcesPlaceholderConfigurer.


new Environment APIs:
@Autowired private Environment env; ... dataSource.setUrl(env.getProperty("jdbc.url"));
-----------------------------------------------------------------------------------------------------------------------------------------------------
Spring java configuration:

https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch03s11.html
https://springframework.guru/spring-framework-annotations/
By default, Spring creates all singleton beans eagerly at the startup/bootstrapping of the application context.
The reason behind this is simple: to avoid and detect all possible errors immediately rather than at runtime.
https://www.baeldung.com/spring-lazy-annotation
------------------------------------------------------------------------------------------------------------------------------------------------------

SEE: Hibernate with Spring (spring tutorial 45) and spring java configuration (including propertyplaceholderconfigurer and all annotations)

https://www.baeldung.com/hibernate-5-spring
https://www.baeldung.com/the-persistence-layer-with-spring-and-jpa

Advantage of using spring data jpa(alongwith hibernate as a jpa provider) over spring+hibernate:
https://stackoverflow.com/questions/23862994/what-is-the-difference-between-hibernate-and-spring-data-jpa
https://dzone.com/articles/what-is-the-difference-between-hibernate-and-sprin-1
Let's say you are using spring + hibernate for your application. Now you need to have dao interface and implementation where you will be writing crud operation using SessionFactory of hibernate. Let say you are writing dao class for Employee class, tomorrow in your application you might need to write similar crud operation for any other entity. So there is lot of boilerplate code we can see here.
Now Spring data jpa allow us to define dao interfaces by extending its repositories(crudrepository, jparepository) so it provide you dao implementation at runtime. You don't need to write dao implementation anymore.Thats how spring data jpa makes your life easy.
So, basically spring jpa is another layer of abstraction on top of hibernate to avoid boilerplate code.

Difference between sessionFactory and entityManagerFactory:
https://stackoverflow.com/questions/5640778/hibernate-sessionfactory-vs-jpa-entitymanagerfactory
Prefer EntityManagerFactory and EntityManager. They are defined by the JPA standard and vendor independent. So if you decide to switch from Hibernate to another JPA provider (EclipseLink, OpenJPA, etc.) you won't have to change your code.
SessionFactory and Session are hibernate-specific. The EntityManager invokes the hibernate session under the hood.

------------------------------------------------------------------------------------------------------------------------------------------------------
Transaction management in spring:
https://www.baeldung.com/transaction-configuration-with-jpa-and-spring
------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Boot with multiple datasources:
https://www.baeldung.com/spring-data-jpa-multiple-databases
https://stackoverflow.com/questions/30337582/spring-boot-configure-and-use-two-datasources
------------------------------------------------------------------------------------------------------------------------------------------------------
SEE: https://www.baeldung.com/spring-interview-questions







