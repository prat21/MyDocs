Reference:
https://docs.oracle.com/javase/tutorial/essential/concurrency/threads.html

https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html
See Synchronized statements and Reentrant Synchronization and their advantages.
"But a thread can acquire a lock that it already owns. Allowing a thread to acquire the same lock more than once enables reentrant synchronization. This describes a situation where synchronized code, directly or indirectly, invokes a method that also contains synchronized code, and both sets of code use the same lock. Without reentrant synchronization, synchronized code would have to take many additional precautions to avoid having a thread cause itself to block."
"Synchronized statements are also useful for improving concurrency with fine-grained synchronization."

--------------------------------------------------------------------------------
Volatile:
https://www.geeksforgeeks.org/volatile-keyword-in-java/
Synchronized keyword provides both atomicity and memory consistency.
Volatile keyword provides only memory consistency and not atomicity. Hence, volatile does not prevent race condition(atomicity). For example changing a shared counter by multiple threads. Because incrementing counter involves multiple steps(read from main memory, modify, write to main memory). All volatile does is ensure that a thread writes directly to main memory after modifying, rather than keeping the modified value in CPU cache. Same goes for read operation also, ie any value is read directly from main memory.
But volatile does not guarantee that when a particular thread is doing "read, modify, write(to main memory)", other thread won't be doing the same set of operations simultaneously, and thus creating a race condition.
Volatile can be used for flags across threads. Als0 double-checked locking in singleton pattern.

Check archived chatgpt "volatile in multithreading"
-------------------------------------------------------------------------------------

Difference between reentrantlock and synchronized:

1) Significant difference between ReentrantLock and synchronized keyword is fairness. synchronized keyword doesn't support fairness. Any thread can acquire lock once released, no preference can be specified, on the other hand you can make ReentrantLock fair by specifying fairness property, while creating instance of ReentrantLock. Fairness property provides lock to the longest waiting thread, in case of contention.

2) Second difference between synchronized and Reentrant lock is tryLock() method. ReentrantLock provides convenient tryLock() method, which acquires lock only if it's available or not held by any other thread. This reduces blocking of thread waiting for lock in Java application.
TryLock is useful to:
a) avoid deadlocks
b) when you want a non-blocking attempt to try a lock
c) for time-out based waiting.
Check archived chatgpt "lock trylock java explained"
https://www.baeldung.com/java-deadlock-livelock#livelock
"TryLock may result in livelock situation where two active threads are handing over the control to other thread repeatedly without being able to complete the task."
"A great example of livelock is a messaging system where, when an exception occurs, the message consumer rolls back the transaction and puts the message back to the head of the queue. Then the same message is repeatedly read from the queue, only to cause another exception and be put back on the queue. The consumer will never pick up any other message from the queue."

3) One more worth noting difference between ReentrantLock and synchronized keyword in Java is, ability to interrupt Thread while waiting for Lock. In case of synchronized keyword, a thread can be blocked waiting for lock, for an indefinite period of time and there was no way to control that. ReentrantLock provides a method called lockInterruptibly(), which can be used to interrupt thread when it is waiting for lock. Similarly tryLock() with timeout can be used to timeout if lock is not available in certain time period.

When a thread calls lockInterruptibly(), it may be interrupted while it is waiting for the lock, so, that it does not wait for the lock indefinitely.

4) ReentrantLock also provides convenient method to get List of all threads waiting for lock.

Read more: https://javarevisited.blogspot.com/2013/03/reentrantlock-example-in-java-synchronized-difference-vs-lock.html

Note about tryLock: Even when this lock has been set to use a fair ordering policy, a call to tryLock() will immediately acquire the lock if it is available, whether other threads are currently waiting for the lock or not. This "barging" behavior can be useful in certain circumstances, even though it breaks fairness.

https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantLock.html#tryLock()

Condition:
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html

Check the implementation logic of ArrayBlockingQueue, especially put and take methods.
Check archived chatgpt "Reentrantlock consequences in java"

A ReentrantLock lock remembers which thread acquired it. ReentrantLock knows the current owning thread. Only the owner can call unlock(). If another thread tries to unlock, it throws IllegalMonitorStateException.
-------------------------------------------------------------------------------------------------------------------------------------------------
Why wait, notify and notifyAll are defined in Object class rather than Thread class:
Check archived chatgpt "Why wait notify in Object" and "Condition vs wait in java"
"If wait() were in Thread, the API would look confusing. Because it's not the thread you wait on, it's the object you synchronized on."
"wait() -> related to intrinsic lock(object lock) and one wait set per object.
Condition -> Related to extrinsic lock(ReentrantLock). Supports multiple wait set per lock"
-------------------------------------------------------------------------------------------------------------------------------------------------
CountDownLatch :
https://www.baeldung.com/java-countdown-latch

When to use join and CountDownLatch:

1. You can only use Thread.join if you're handling the threads yourself. Most people choose not to deal with the minutia of thread handling directly, and instead use an ExecutorService to handle it for them. ExecutorServices do not directly reveal how they are executing tasks, so you would have to use a CountDownLatch: (Assuming you don't want to just shutdown the whole service, that is.)


ExecutorService service = Executors.newFixedThreadPool(5);
final CountDownLatch latch = new CountDownLatch(5);

for(int x = 0; x < 5; x++) {
    service.submit(new Runnable() {
        public void run() {
            // do something
            latch.countDown();
        }
    });
}

latch.await();


2. Another difference is after join(), thread can be unblocked only when joined thread has finished its execution while in CountDownLatch a thread can decrease the count anytime either on completion of thread or in between based on any condition.
This way we can get better control over unblocking of the thread instead of solely depending on the completion of joined thread.

https://stackoverflow.com/questions/12254704/what-is-the-difference-between-join-and-countdownlatch

-------------------------------------------------------------------------------------------------------------------------------------------------

BrokenBarrierException:

A barrier breaks when any of the waiting thread leaves the barrier. This happens when one or more waiting thread is interrupted or when the waiting time is completed because the thread called the await() methods with a timeout as follows:

newBarrier.await(1000, TimeUnit.MILLISECONDS);
// thread calling this await() 
// methods waits for only 1000 milliseconds.
When the barrier breaks due to one of more participating threads, the await() methods of all the other threads throws a BrokenThreadException. Whereas, the threads that are already waiting in the barriers have their await() call terminated.

Difference between a CyclicBarrier and a CountDownLatch

A CountDownLatch can be used only once in a program(until it’s count reaches 0).
A CyclicBarrier can be used again and again once all the threads in a barriers is released.


-------------------------------------------------------------------------------------------------------------------------------------------------
Mutex is the Semaphore with an access count of 1.

See difference between mutex,semaphore and binary semaphore.

Check archived chatgpt "semaphore in java", "semaphore and connection pool", "binary semaphore vs reentrantlock"

A semaphore is not reentrant in the sense that, a thread cannot acquire a single permit more than once. If it does "acquire()" repeatedly it will gain new permits(if available).

Check archived chatgpt "semaphore ownership in java"
A Semaphore is just a counter of available permits.
1) When a thread calls acquire(), it decrements the counter.
2) When a thread calls release(), it increments the counter.
3) It does not care which thread acquired or released the permit.

This design makes sense because:
1) Semaphores are meant for resource management (like limiting access to a pool of DB connections or printers), not just mutual exclusion.
2) Ownership would restrict usage — for example:
Thread A acquires a permit (starts using a resource).
Thread B, after finishing the work, should be able to release it.
With ownership, this pattern wouldn’t work.

--------------------------------------------------------------------------------------------------------------------------------------------------

Q. How to prevent deadlock?

A. The problem discussed before can be avoided by applying a suitable deadlock prevention technique. Following are some techniques available that help mitigate the deadlock problem:

Avoid Nested Locks (avoid locking another resource if you already hold one)
Lock Ordering
Lock Timeout
Single Thread

http://www.javacreed.com/what-is-deadlock-and-how-to-prevent-it/
http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html


Q. How do you detect deadlock in Java ?

A. Though this could have many answers , my version is first I would look the code if I see nested synchronized block or calling one synchronized method from other or trying to get lock on different object then there is good chance of deadlock if developer is not very careful.

Other way is to find it when you actually get locked while running the application , try to take thread dump , in Linux you can do this by command "kill -3" , this will print status of all the thread in application log file and you can see which thread is locked on which object. 

Other way is to use jconsole, it will show you exactly which threads are get locked and on which object.

Read more: https://javarevisited.blogspot.com/2010/10/what-is-deadlock-in-java-how-to-fix-it.html#ixzz5KmtRQPft

--------------------------------------------------------------------------------------------------------------------------------------------------

ExecutorService:

https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html
http://www.baeldung.com/java-executor-service-tutorial
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html
(Has explanation about corepoolsize, maxpoolsize, keepAliveTime, Unbounded/Bounded queue)

a. If fewer than CorePoolSize threads are running, the Executor always prefers creating a new thread rather than queuing.
b. If CorePoolSize or more threads are running, the Executor always prefers queuing a request rather than creating a new thread.
c. If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.

https://howtodoinjava.com/java/multi-threading/how-to-use-blockingqueue-and-threadpoolexecutor-in-java/

Note: ExecutorService abstracts away the thread management and lifecycle overheads. We just create a thread pool with desired pool size and submit the tasks that we want to execute. ExecutorService takes care of the rest.

Check archived chatgpt "thread pool types"
Check archived chatgpt "CorePoolSize vs MaxPoolsize" to check how corepoolsize and maxpoolsize relate to different thread pools.
Check chatgpt "Executor.shutdown explanation"
--------------------------------------------------------------------------------------------------------------------------------------------------

Callable: Main difference between Runnable and Callable is that Runnable cannot return any value back to caller but Callable can return value. Another difference is that call() method from Callable can also throw checked exception which was not possible by run() method of Runnable interface. 

Read more: https://javarevisited.blogspot.com/2015/06/how-to-use-callable-and-future-in-java.html#ixzz5LADCr7Rx


Future:  You can use get() method of Future to retrieve result once computation is done. You can check if computation is finished or not by using isDone() method.
You can cancel the computation by using Future.cancel() method.
get() is a blocking call and it blocks until computation is completed.
Future.get method is not asynchronous and waits till it gets actual result.

Read more: https://javarevisited.blogspot.com/2015/06/how-to-use-callable-and-future-in-java.html#ixzz5LAEawaaf

Java Callable tasks return java.util.concurrent.Future objects. Java Future provides a cancel() method to cancel the associated Callable task. This is an overloaded version of the get() method, where we can specify the time to wait for the result. It’s useful to avoid a current thread getting blocked for a longer time. Please note that the get method is a synchronous method. Until the callable finishes its task and returns a value, it will wait for a callable. There are also isDone() and isCancelled() methods to find out the current status of an associated Callable task

--------------------------------------------------------------------------------------------------------------------------------------------------

Difference between wait, sleep and yield:

https://infinitescript.com/2014/09/difference-between-wait-and-sleep-yield-in-java/
--------------------------------------------------------------------------------------------------------------------------------------------------
Multithreading in single vs multi processor:
https://docs.oracle.com/cd/E19253-01/816-5137/mtintro-25092/index.html#:~:text=In%20a%20multithreaded%20process%20on,are%20not%20actually%20running%20simultaneously.

In a multithreaded process on a single processor, the processor can switch execution resources between threads, resulting in concurrent execution.
Concurrency indicates that more than one thread is making progress, but the threads are not actually running simultaneously.
The switching between threads happens quickly enough that the threads might appear to run simultaneously.

In the same multithreaded process in a shared-memory multiprocessor environment, each thread in the process can run concurrently on a separate processor, resulting in parallel execution, which is true simultaneous execution.
When the number of threads in a process is less than or equal to the number of processors available, the operating system's thread support system ensures that each thread runs on a different processor.
For example, in a matrix multiplication that is programmed with four threads, and runs on a system that has two dual-core processors, each software thread can run simultaneously on the four processor cores to compute a row of the result at the same time.
--------------------------------------------------------------------------------------------------------------------------------------------------
Atomic variables:
https://www.baeldung.com/java-atomic-variables
When multiple threads attempt to update the same value through CAS, one of them wins and updates the value.
However, unlike in the case of locks, no other thread gets suspended; instead, they're simply informed that they did not manage to update the value.
The threads can then proceed to do further work and context switches are completely avoided.
https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html
Note: For "compareAndSet()" to work, we first need to get the current value of the variable using "get()" method and then use that value(as the value to compare with) in compareAndSet(). For the method "getAndIncrement()" this sequence of operations happens automatically.

long getAndTransform(AtomicLong var) {
   long prev, next;
   do {
     prev = var.get();
     next = transform(prev);
   } while (!var.compareAndSet(prev, next));
   return prev; // return next; for transformAndGet
}
--------------------------------------------------------------------------------------------------------------------------------------------------
Race Condition:
http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html
--------------------------------------------------------------------------------------------------------------------------------------------------
CompletableFuture:
https://forums.oracle.com/ords/apexds/post/completablefuture-for-asynchronous-programming-in-java-8-8539
"If no ExecutorService is supplied(to the completableFuture), the tasks will be executed in the common fork/join pool, the same pool that is used for the parallel execution of streams."
"All these methods(thenApply, thenAccept, thenRun) execute their tasks in the same thread as the upstream task. If we want these tasks to be executed in a separate thread then we have to use the "async" variants. These methods can take a further suffix: async(thenRunAsync for example). An async method executes its task in the default fork/join pool, unless it takes an Executor, in which case, the task will be executed in this Executor."

https://www.baeldung.com/java-completablefuture-threadpool
https://medium.com/javarevisited/completablefuture-usage-and-best-practises-4285c4ceaad4

Why completableFuture was introduced even though Future interface was there:
1. There was no way to make get() call non-blocking in Future.
2. No support for exception handling.
3. Chaining of callbacks was not supported.
4. There was no way to explicitly complete the task.
https://www.callicoder.com/java-8-completablefuture-tutorial/
The join() method is similar to get(). The only difference is that it throws an unchecked exception if the underlying CompletableFuture completes exceptionally.
Check archived chatgpt "get vs join completablefuture"
Check archived chatgpt "completable future in java" (Especially check the section explaining different states of completionstage)
--------------------------------------------------------------------------------------------------------------------------------------------------
Check threadLocal and fork/join pool.